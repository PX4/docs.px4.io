import{_ as i,c as s,a8 as t,o as e}from"./chunks/framework.BDnHobkS.js";const k=JSON.parse('{"title":"Запуск системи","description":"","frontmatter":{},"headers":[],"relativePath":"uk/concept/system_startup.md","filePath":"uk/concept/system_startup.md"}'),o={name:"uk/concept/system_startup.md"};function l(n,a,p,c,r,d){return e(),s("div",null,a[0]||(a[0]=[t(`<h1 id="запуск-системи" tabindex="-1">Запуск системи <a class="header-anchor" href="#запуск-системи" aria-label="Permalink to &quot;Запуск системи&quot;">​</a></h1><p>Запуск PX4 контрольований скриптами оболонки. На NuttX вони знаходяться у директорії <a href="https://github.com/PX4/PX4-Autopilot/tree/main/ROMFS/px4fmu_common/init.d" target="_blank" rel="noreferrer">ROMFS/px4fmu_common/init.d</a>, деякі з них також використовуються на Posix системах (Linux/MacOS). Скрипти які використовуються тільки на Posix системах знаходяться у <a href="https://github.com/PX4/PX4-Autopilot/tree/main/ROMFS/px4fmu_common/init.d-posix" target="_blank" rel="noreferrer">ROMFS/px4fmu_common/init.d-posix</a>.</p><p>Усі файли, які починаються з числа і підкреслення (наприклад, <code>10000_airaipl</code>) є попередньо визначеними конфігураціями планерів. Вони експортуються під час збірки в файл <code>airframes.xml</code> який потім аналізується <a href="http://qgroundcontrol.com" target="_blank" rel="noreferrer">QGroundControl</a> для користувацького інтерфейсу вибору планера. Як додати нову конфігурацію описано <a href="./../dev_airframes/adding_a_new_frame.html">тут</a>.</p><p>Файли що залишилися є частиною загальної логіки запуску. Перший файл що виконується є скрипт <a href="https://github.com/PX4/PX4-Autopilot/blob/main/ROMFS/px4fmu_common/init.d/rcS" target="_blank" rel="noreferrer">init.d/rcS</a> (або <a href="https://github.com/PX4/PX4-Autopilot/blob/main/ROMFS/px4fmu_common/init.d-posix/rcS" target="_blank" rel="noreferrer">init.d-posix/rcS</a> на Posix), який викликає інші скрипти.</p><p>Наступні секції розділені відповідно до операційної системи, на яких виконується PX4.</p><h2 id="posix-linux-macos" tabindex="-1">Posix (Linux/MacOS) <a class="header-anchor" href="#posix-linux-macos" aria-label="Permalink to &quot;Posix (Linux/MacOS)&quot;">​</a></h2><p>На Posix системна оболонка використовується як інтерпретатор скриптів (наприклад, /bin/sh що є символьним посиланням на dash в Ubuntu). Щоб це працювало потрібно кілька речей:</p><ul><li><p>Модулі PX4 повинні виглядати для системи як окремі виконувані файли. Це робиться за допомогою символьних посилань. For each module a symbolic link <code>px4-&lt;module&gt; -&gt; px4</code> is created in the <code>bin</code> directory of the build folder. При виконанні двійкового файлу перевіряється його шлях (<code>argv[0]</code>) і якщо це модуль (починається з <code>px4-</code>) він відправляє команду на основний екземпляр px4 (див. нижче).</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>The <code>px4-</code> prefix is used to avoid conflicts with system commands (e.g. <code>shutdown</code>), and it also allows for simple tab completion by typing <code>px4-&lt;TAB&gt;</code>.</p></div></li></ul><p>:::</p><ul><li><p>Оболонка повинна знати, де шукати символьні посилання. For that the <code>bin</code> directory with the symbolic links is added to the <code>PATH</code> variable right before executing the startup scripts.</p></li><li><p>Оболонка запускає кожен модуль як новий (клієнтський) процес. Кожен клієнтський процес повинен спілкуватися з головним екземпляром px4 (сервером), де справжні модулі працюють як потоки. Це зроблено через <a href="http://man7.org/linux/man-pages/man7/unix.7.html" target="_blank" rel="noreferrer">сокет UNIX</a>. Сервер прослуховує сокет, до якого клієнти можуть під&#39;єднатися та надіслати команду. Сервер відправляє вихідні дані та код повернення назад до клієнта.</p></li><li><p>The startup scripts call the module directly, e.g. <code>commander start</code>, rather than using the <code>px4-</code> prefix. This works via aliases: for each module an alias in the form of <code>alias &lt;module&gt;=px4-&lt;module&gt;</code> is created in the file <code>bin/px4-alias.sh</code>.</p></li><li><p>Скрипт <code>rcS</code> виконується з основного екземпляра Px4. Він не запускає жодних модулів, але спочатку оновлює змінну <code>PATH</code>, а потім просто запускає оболонку з файлом <code>rcS</code> як аргумент.</p></li><li><p>Крім того, декілька екземплярів серверу можуть бути запущені для симуляції кількох засобів. A client selects the instance via <code>--instance</code>. В скрипті екземпляр доступний за допомогою змінної <code>$px4_instance</code>.</p></li></ul><p>Модулі можна виконувати з будь-якого терміналу, коли PX4 вже запущено в системі. Наприклад:</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">PX4-Autopilo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/build/px4_sitl_default/bin</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./px4-commander</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> takeoff</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./px4-listener</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sensor_accel</span></span></code></pre></div><h3 id="динамічні-модулі" tabindex="-1">Динамічні модулі <a class="header-anchor" href="#динамічні-модулі" aria-label="Permalink to &quot;Динамічні модулі&quot;">​</a></h3><p>Зазвичай всі модулі компілюються в єдиний виконуваний файл PX4. Однак, на Posix системах, є можливість компіляції модуля в окремий файл, який можна завантажити в PX4 використовуючи команду <code>dyn</code>.</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dyn</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./test.px4mod</span></span></code></pre></div><h2 id="nuttx" tabindex="-1">NuttX <a class="header-anchor" href="#nuttx" aria-label="Permalink to &quot;NuttX&quot;">​</a></h2><p>NuttX має інтегрований інтерпретатор оболонки (<a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=139629410" target="_blank" rel="noreferrer">NuttShell (NSH)</a>), тому скрипти можуть бути виконані безпосередньо.</p><h3 id="налагодження-завантаження-системи" tabindex="-1">Налагодження завантаження системи <a class="header-anchor" href="#налагодження-завантаження-системи" aria-label="Permalink to &quot;Налагодження завантаження системи&quot;">​</a></h3><p>Відмова драйверу програмного компонента не призведе до перерваного завантаження. Це контролюється директивою <code>set +e</code> в скрипті запуску.</p><p>Послідовність завантаження можна налагодити під&#39;єднавши <a href="./../debug/system_console.html">системну консоль</a> та перезавантажити плату за живленням. Отриманий журнал завантаження містить детальну інформацію про послідовність завантажування і має містити підказки, чому завантаження переривалось.</p><h4 id="основні-причини-невдалого-завантаження" tabindex="-1">Основні причини невдалого завантаження <a class="header-anchor" href="#основні-причини-невдалого-завантаження" aria-label="Permalink to &quot;Основні причини невдалого завантаження&quot;">​</a></h4><ul><li>Для користувацьких додатків: у системі закінчилася оперативна пам&#39;ять. Run the <code>free</code> command to see the amount of free RAM.</li><li>Відмова програмного забезпечення або припущення яке призвело до трасування стеку.</li></ul><h3 id="заміна-запуску-системи" tabindex="-1">Заміна запуску системи <a class="header-anchor" href="#заміна-запуску-системи" aria-label="Permalink to &quot;Заміна запуску системи&quot;">​</a></h3><p>Весь процес завантаження може бути замінений шляхом створення файлу з новою конфігурацією <code>/etc/rc.txt</code> на картці microSD (ніщо в старій конфігурації не буде автоматично запущено, і якщо файл порожній, зовсім нічого не буде запущено).</p><p>Налаштування стандартного завантаження майже завжди є кращим підходом. Це описано нижче.</p><h3 id="налаштування-запуску-системи" tabindex="-1">Налаштування запуску системи <a class="header-anchor" href="#налаштування-запуску-системи" aria-label="Permalink to &quot;Налаштування запуску системи&quot;">​</a></h3><p>Найкращий спосіб змінити запуск системи - це ввести <a href="./../dev_airframes/adding_a_new_frame.html">нову конфігурацію планера</a>. Файл конфігурації планеру може бути включений у прошивку або на SD карту.</p><p>Якщо вам потрібно &quot;підлаштувати&quot; конфігурацію що існує, наприклад запустити один або більше застосунків або встановити значення кількох параметрів, можна вказати це створивши два файли у директорії <code>/etc/</code> на SD картці:</p><ul><li><a href="#customizing-the-configuration-config-txt">/etc/config.txt</a>: modify parameter values</li><li><a href="#starting-additional-applications-extras-txt">/etc/extras.txt</a>: start applications</li></ul><p>Ці файли описані нижче.</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>Системні файли завантаження - це UNIX файли, які потребують закінчення рядків UNIX. Якщо редагуєте їх на Windows - використовуйте відповідний редактор.</p></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Ці файли згадуються в коді PX4 як <code>/fs/microsd/etc/config.txt</code> та <code>/fs/microsd/etc/extras.txt</code>, де коренева директорія microSD карти визначається шляхом <code>/fs/microsd</code>.</p></div><h4 id="налаштування-конфігураціі-config-txt" tabindex="-1">Налаштування конфігурації (config.txt) <a class="header-anchor" href="#налаштування-конфігураціі-config-txt" aria-label="Permalink to &quot;Налаштування конфігурації (config.txt)&quot;">​</a></h4><p>Файл <code>config.txt</code> можна використовувати для зміни параметрів. Він завантажується після того, як головна система була налаштована та <em>перед тим</em> як завантажена.</p><p>Наприклад, ви можете створити файл на SD картці, <code>etc/config.txt</code> з такими значеннями параметрів як показано:</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">param</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> set-default</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> PWM_MAIN_DIS3</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">param</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> set-default</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> PWM_MAIN_MIN3</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1120</span></span></code></pre></div><h4 id="запуск-додаткових-застосунків-extras-txt" tabindex="-1">Запуск додаткових застосунків (extras.txt) <a class="header-anchor" href="#запуск-додаткових-застосунків-extras-txt" aria-label="Permalink to &quot;Запуск додаткових застосунків (extras.txt)&quot;">​</a></h4><p><code>extras.txt</code> можна використовувати для запуску додаткових застосунків після завантаження основної системи. Зазвичай це будуть контролери корисного навантаження або подібні необов&#39;язкові користувацькі компоненти.</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>Виклик невідомої команди в файлах завантаження системи може призвести до збою завантаження. Зазвичай система не транслює повідомлення mavlink після збою при завантаженні, в такій ситуації перевірте повідомлення про помилки, які виведено в системній консолі.</p></div><p>Наступний приклад показує, як запускати користувацькі застосунки:</p><ul><li><p>Створіть файл на SD картці <code>etc/extras.txt</code> із цим вмістом:</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">custom_app</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> start</span></span></code></pre></div></li><li><p>Команду можна зробити необов&#39;язковою шляхом оздоблення команди директивами <code>set +e</code> та <code>set -e</code>:</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> +e</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">optional_app</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> start</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      # Will not result in boot failure if optional_app is unknown or fails</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -e</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mandatory_app</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> start</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     # Will abort boot if mandatory_app is unknown or fails</span></span></code></pre></div></li></ul>`,41)]))}const u=i(o,[["render",l]]);export{k as __pageData,u as default};
