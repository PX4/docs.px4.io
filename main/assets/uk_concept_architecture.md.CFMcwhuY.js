import{_ as i,a as s}from"./chunks/PX4_High-Level_Flight-Stack.B3u3dIZd.js";import{_ as t,c as e,a8 as l,o as p}from"./chunks/framework.BDnHobkS.js";const g=JSON.parse('{"title":"Огляд архітектури PX4","description":"","frontmatter":{},"headers":[],"relativePath":"uk/concept/architecture.md","filePath":"uk/concept/architecture.md"}'),n={name:"uk/concept/architecture.md"};function r(h,a,o,d,c,k){return p(),e("div",null,a[0]||(a[0]=[l('<h1 id="огляд-архітектури-px4" tabindex="-1">Огляд архітектури PX4 <a class="header-anchor" href="#огляд-архітектури-px4" aria-label="Permalink to &quot;Огляд архітектури PX4&quot;">​</a></h1><p>PX4 складається із двох головних шарів: <a href="#flight-stack">набору політного ПЗ</a>, що є системою керування та оцінки польоту, та <a href="#middleware">проміжного ПЗ</a>, яке є загальним робототехнічним прошарком ПЗ, що може підтримувати будь-який тип автономного робота, забезпечуючи внутрішній та зовнішній зв&#39;язок та інтеграцію апаратного забезпечення.</p><p>Всі <a href="./../airframes/README.html">планери</a> PX4 мають окрему кодову базу (включаючи й інші роботизовані системи, такі як човни, ровери, підводні човни тощо). Побудова системи є <a href="http://www.reactivemanifesto.org" target="_blank" rel="noreferrer">реакційною</a>, це означає що:</p><ul><li>Весь функціонал розділений на взаємозамінні та придатні для повторного використання компоненти</li><li>Зв&#39;язок зроблено через асинхронне передавання повідомлень</li><li>Система може дати раду різним робочим навантаженням</li></ul><p><a id="architecture"></a></p><h2 id="високорівнева-архітектура-пз" tabindex="-1">Високорівнева архітектура ПЗ <a class="header-anchor" href="#високорівнева-архітектура-пз" aria-label="Permalink to &quot;Високорівнева архітектура ПЗ&quot;">​</a></h2><p>На діаграмі нижче показано детальний огляд будівельних блоків PX4. Верхня частина діаграми містить блоки проміжного ПЗ, тоді як нижня частина - компоненти набору польотного ПЗ.</p><p><img src="'+i+'" alt="PX4 Architecture"></p><p>Вихідний код розділено на самодостатні модулі/програми (показано на діаграмі <code>моноширинним</code> шрифтом). Зазвичай один блок відповідає одному модулю.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Під час виконання можна переглянути який з модулів виконується за допомогою команди <code>top</code> в консолі, а кожен модуль може бути запущено окремо за допомогою <code>&lt;module_name&gt; start/stop</code>. Хоча команда <code>top</code> характерна для оболонки NuttX, інші команди можуть бути використані також в оболонці SITL (pxh&gt;). Для додаткової інформації про кожен з цих модулів дивіться <a href="./../modules/modules_main.html">Довідник команд та модулів</a>.</p></div><p>Стрілки показують плин інформації для <em>найважливіших</em> зв&#39;язків між модулями. В реальності зв&#39;язків набагато більше ніж показано, а деякі дані (наприклад параметри) отримуються більшістю модулів.</p><p>Модулі спілкуються один з одним через шину повідомлень публікації/підписки яка називається <a href="./../middleware/uorb.html">uORB</a>. Використання схеми публікації/підписки означає, що:</p><ul><li>Система реакційна — тобто є асинхронною та миттєво оновиться при наявності нових даних</li><li>Всі операції та комунікації повністю розпаралелено</li><li>Системний компонент може споживати дані звідки завгодно у спосіб безпечний для потоків</li></ul><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Ця архітектура дозволяє швидко і легко замінити кожен з цих блоків навіть під час виконання.</p></div><h3 id="набір-польотного-пз" tabindex="-1">Набір польотного ПЗ <a class="header-anchor" href="#набір-польотного-пз" aria-label="Permalink to &quot;Набір польотного ПЗ&quot;">​</a></h3><p>Набір польотного ПЗ є колекцією алгоритмів керування, навігації та спрямування для автономних дронів. Він включає контролери для планерів з фіксованим крилом, мультироторів та ВЗІП, а також спостерігача орієнтації та позиції.</p><p>У наступній діаграмі показано огляд будівельних блоків набору ПЗ для польоту. Він містить повний конвеєр від датчиків, вхідних даних РК та контролера автономного польоту (Navigator), до двигуна або управління сервоприводами (Actuators).</p><p><img src="'+s+`" alt="Високорівнева схема набору політного ПЗ у PX4"></p><p><strong>Спостерігач</strong> приймає вхідні дані з одного або більше датчиків, поєднує їх та обчислює стан рухомого засобу (наприклад орієнтацію з даних датчика ІВП або ж IMU).</p><p><strong>Контролер</strong> - це компонент, який приймає на вхід заданий і виміряний або ж визначений стан (змінну процесу). Його мета - скорегувати значення змінної процесу, таким чином, щоб вона відповідала заданому значенню. Вихідні дані - це корекційні значення, щоб врешті-решт досягти заданих. Наприклад, контролер позиції приймає задані значення позиції на вході, змінна процесу є значенням позиції що оцінюється, а вихід - це орієнтація та задане значення газу, що рухає засіб до потрібної позиції.</p><p><strong>Змішувач</strong> приймає команди примусу (наприклад &quot;повернути вправо&quot;) і перекладає їх на окремі команди двигуна, при цьому гарантуючи, що певні межі не перевищено. Цей переклад є специфічним для типу засобу і залежить від різних факторів такі як розташування двигунів відносно центру мас або інерція обертання засобу.</p><p><a id="middleware"></a></p><h3 id="проміжне-програмне-забезпечення" tabindex="-1">Проміжне програмне забезпечення <a class="header-anchor" href="#проміжне-програмне-забезпечення" aria-label="Permalink to &quot;Проміжне програмне забезпечення&quot;">​</a></h3><p><a href="./../middleware/README.html">Проміжне ПЗ</a> головним чином складається з драйверів для вбудованих датчиків, зв&#39;язку із зовнішнім світом (допоміжним комп&#39;ютером, GCS і т ін.) та шиною повідомлень uORB.</p><p>Крім того, в проміжне ПЗ включено <a href="./../simulation/README.html">шар симуляції</a>, який дозволяє коду PX4 запускатися на настільній операційній системі та контролювати модельований комп&#39;ютером рухомий засіб у симульованому &quot;світі&quot;.</p><h2 id="темпи-оновлення-даних" tabindex="-1">Темпи оновлення даних <a class="header-anchor" href="#темпи-оновлення-даних" aria-label="Permalink to &quot;Темпи оновлення даних&quot;">​</a></h2><p>Оскільки модулі очікують оновлень повідомлень, зазвичай драйвери визначають як швидко оновлюється стан модуля. Більшість драйверів ІВП роблять вибірку даних на частоті 1 кГц, інтегрують їх і публікують з частотою 250 Гц. Інші частини системи, такі як <code>navigator</code> не потребують такої високої швидкості поновлення даних тому виконуються значно повільніше.</p><p>Частота оновлення повідомлень на системі може бути <a href="./../middleware/uorb.html">перевірена</a> в реальному часі, запустивши команду <code>uorb top</code>.</p><p><a id="runtime-environment"></a></p><h2 id="середовище-виконання" tabindex="-1">Середовище виконання <a class="header-anchor" href="#середовище-виконання" aria-label="Permalink to &quot;Середовище виконання&quot;">​</a></h2><p>PX4 запускається на різних операційних системах які надають POSIX-API (наприклад, Linux, macOS, NuttX або QuRT). Вони також повинні мати якусь форму планування завдань в реальному часі (наприклад FIFO).</p><p>Комунікація між модулями (за допомогою <a href="./../middleware/uorb.html">uORB</a>) заснована на розділюваній пам&#39;яті. Усе проміжне ПЗ PX4 виконується в єдиному адресному просторі, тобто пам&#39;ять розділена між усіма модулями.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Система створена так, щоб з мінімальними зусиллями, можна було б запустити кожен модуль в окремому адресному просторі (частини, які необхідно буде змінити включають <code>uORB</code>, <code>parameter interface</code>, <code>dataman</code> та <code>perf</code>).</p></div><p>Існує 2 різні способи запуску модуля:</p><ul><li><p><strong>Завдання</strong>: Модуль виконується у своєму власному завданні з власним стеком і пріоритетом процесу.</p></li><li><p><strong>Завдання робочої черги</strong>: Модуль виконується в спільній робочій черзі, розділяючи той самий стек та пріоритет потоку робочої черги як і інші модулі в черзі.</p><ul><li>Усі завдання повинні поводитися скооперовано, оскільки вони не можуть переривати одне одного.</li><li>Декілька <em>завдань робочої черги</em> можуть запускатися у черзі, а також може бути кілька черг.</li><li><em>Завдання робочої черги</em> планується вказанням визначеного часу у майбутньому або через зворотний виклик &quot;поновлення теми&quot; uORB.</li></ul><p>Перевага запуску модулів у робочій черзі полягає в тому, що це використовує менше ОЗП, і потенційно призводить до меншої кількості перемикань завдань. Недоліки в тому, що <em>завданням робочої черги</em> не дозволено перебувати в режимі сну або опитувати наявність повідомлення, або виконувати блокуючу операцію вводу/виводу (наприклад, читання з файлу). Довгострокові завдання (що виконують важкі обчислення) повинні потенційно також запускатися в окремому завданні або принаймні в окремій робочий черзі.</p></li></ul><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Завдання запущені в робочій черзі не з&#39;являються у виводі <a href="./../modules/modules_command.html#top"><code>top</code></a> (видно тільки робочі як такі, наприклад <code>wq:lp_default</code>). Використовуйте <a href="./../modules/modules_system.html#work-queue"><code>work_queue status</code></a> для показу всіх активних елементів черги.</p></div><h3 id="фонові-завдання" tabindex="-1">Фонові завдання <a class="header-anchor" href="#фонові-завдання" aria-label="Permalink to &quot;Фонові завдання&quot;">​</a></h3><p><code>px4_task_spawn_cmd()</code> використовується для запуску нових завдань (NuttX) або потоків (POSIX - Linux/macOS), які працюють незалежно від (батьківського) завдання, що їх викликало:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">independent_task </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> px4_task_spawn_cmd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;commander&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                    // Process name</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    SCHED_DEFAULT,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                  // Scheduling type (RR or FIFO)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    SCHED_PRIORITY_DEFAULT </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 40</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Scheduling priority</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    3600</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                           // Stack size of the new task or thread</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    commander_thread_main,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // Task (or thread) main function</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">argv[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Void pointer to pass to the new task</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                                    // (here the commandline arguments).</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    );</span></span></code></pre></div><h3 id="інформація-для-певноі-ос" tabindex="-1">Інформація для певної ОС <a class="header-anchor" href="#інформація-для-певноі-ос" aria-label="Permalink to &quot;Інформація для певної ОС&quot;">​</a></h3><h4 id="nuttx" tabindex="-1">NuttX <a class="header-anchor" href="#nuttx" aria-label="Permalink to &quot;NuttX&quot;">​</a></h4><p><a href="https://nuttx.apache.org//" target="_blank" rel="noreferrer">NuttX</a> є основною RTOS для запуску PX4 на платі керування польотами. Вона має відкритий вихідний код (під BSD ліцензією), легка, ефективна і дуже стабільна.</p><p>Модулі виконуються як завдання: вони мають свої списки дескрипторів файлів, але мають єдиний адресний простір. Завдання все ще може запустити один або кілька потоків, які розділяють той самий список дескрипторів файлів.</p><p>Кожне завдання/поток має стек фіксованого розміру, є періодичне завдання, яке перевіряє, що в всіх стеках залишилося достатньо вільного місця (засновано на розфарбовуванні стеку).</p><h4 id="linux-macos" tabindex="-1">Linux/macOS <a class="header-anchor" href="#linux-macos" aria-label="Permalink to &quot;Linux/macOS&quot;">​</a></h4><p>На Linux або macOS, PX4 виконується в одному процесі, а модулі запускаються у своїх потоках (бо немає різниці між завданнями та потоками як на NuttX).</p>`,46)]))}const E=t(n,[["render",r]]);export{g as __pageData,E as default};
