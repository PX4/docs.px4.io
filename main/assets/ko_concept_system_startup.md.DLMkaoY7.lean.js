import{_ as a,c as t,a8 as i,o as s}from"./chunks/framework.BDnHobkS.js";const u=JSON.parse('{"title":"시스템 시작","description":"","frontmatter":{},"headers":[],"relativePath":"ko/concept/system_startup.md","filePath":"ko/concept/system_startup.md"}'),o={name:"ko/concept/system_startup.md"};function n(l,e,r,c,d,h){return s(),t("div",null,e[0]||(e[0]=[i(`<h1 id="시스템-시작" tabindex="-1">시스템 시작 <a class="header-anchor" href="#시스템-시작" aria-label="Permalink to &quot;시스템 시작&quot;">​</a></h1><p>PX4 시작은 쉘 스크립트에 의해 제어됩니다. On NuttX they reside in the <a href="https://github.com/PX4/PX4-Autopilot/tree/main/ROMFS/px4fmu_common/init.d" target="_blank" rel="noreferrer">ROMFS/px4fmu_common/init.d</a> folder - some of these are also used on Posix (Linux/MacOS). The scripts that are only used on Posix are located in <a href="https://github.com/PX4/PX4-Autopilot/tree/main/ROMFS/px4fmu_common/init.d-posix" target="_blank" rel="noreferrer">ROMFS/px4fmu_common/init.d-posix</a>.</p><p>All files starting with a number and underscore (e.g. <code>10000_airplane</code>) are predefined airframe configurations. They are exported at build-time into an <code>airframes.xml</code> file which is parsed by <a href="http://qgroundcontrol.com" target="_blank" rel="noreferrer">QGroundControl</a> for the airframe selection UI. Adding a new configuration is covered <a href="./../dev_airframes/adding_a_new_frame.html">here</a>.</p><p>나머지 파일은 공통 시작 로직의 일부입니다. The first executed file is the <a href="https://github.com/PX4/PX4-Autopilot/blob/main/ROMFS/px4fmu_common/init.d/rcS" target="_blank" rel="noreferrer">init.d/rcS</a> script (or <a href="https://github.com/PX4/PX4-Autopilot/blob/main/ROMFS/px4fmu_common/init.d-posix/rcS" target="_blank" rel="noreferrer">init.d-posix/rcS</a> on Posix), which calls all other scripts.</p><p>다음 섹션은 PX4가 실행되는 운영 체제에 따라 달라집니다.</p><h2 id="posix-linux-macos" tabindex="-1">POSIX (Linux/MacOS) <a class="header-anchor" href="#posix-linux-macos" aria-label="Permalink to &quot;POSIX (Linux/MacOS)&quot;">​</a></h2><p>Posix에서 시스템 셸은 스크립트 인터프리터로 사용됩니다(예: /bin/sh, Ubuntu에서 dash에 심볼릭 링크됨). 동작하기 위한 몇가지 조건이 있습니다.</p><ul><li><p>PX4 모듈은 시스템에서 개별적으로 실행할 수 있어야합니다. 이 동작은 심볼릭 링크로 처리합니다. For each module a symbolic link <code>px4-&lt;module&gt; -&gt; px4</code> is created in the <code>bin</code> directory of the build folder. When executed, the binary path is checked (<code>argv[0]</code>), and if it is a module (starts with <code>px4-</code>), it sends the command to the main px4 instance (see below).</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>The <code>px4-</code> prefix is used to avoid conflicts with system commands (e.g. <code>shutdown</code>), and it also allows for simple tab completion by typing <code>px4-&lt;TAB&gt;</code>.</p></div></li></ul><p>:::</p><ul><li><p>쉘은 심볼릭 링크를 찾을 위치를 알고 있어야 합니다. For that the <code>bin</code> directory with the symbolic links is added to the <code>PATH</code> variable right before executing the startup scripts.</p></li><li><p>쉘은 각 모듈을 새로운(클라이언트) 프로세스로 시작합니다. 각 클라이언트 프로세스는 실제 모듈이 스레드로 실행되는 px4(서버)의 기본 인스턴스와 통신합니다. This is done through a <a href="http://man7.org/linux/man-pages/man7/unix.7.html" target="_blank" rel="noreferrer">UNIX socket</a>. 서버는 클라이언트가 연결하고 명령을 보낼 수 있는 소켓으로 수신 대기합니다. 그런 다음 서버는 출력과 반환 코드를 다시 클라이언트로 전송합니다.</p></li><li><p>The startup scripts call the module directly, e.g. <code>commander start</code>, rather than using the <code>px4-</code> prefix. This works via aliases: for each module an alias in the form of <code>alias &lt;module&gt;=px4-&lt;module&gt;</code> is created in the file <code>bin/px4-alias.sh</code>.</p></li><li><p>The <code>rcS</code> script is executed from the main px4 instance. It does not start any modules, but first updates the <code>PATH</code> variable and then simply runs a shell with the <code>rcS</code> file as argument.</p></li><li><p>그 외에도, 다중 기체 시뮬레이션을 위하여 여러 서버 인스턴스를 시작할 수 있습니다. A client selects the instance via <code>--instance</code>. The instance is available in the script via <code>$px4_instance</code> variable.</p></li></ul><p>모듈은 PX4가 시스템에서 실행 중이면, 터미널에서 실행할 수 있습니다. 예:</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">PX4-Autopilo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/build/px4_sitl_default/bin</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./px4-commander</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> takeoff</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./px4-listener</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sensor_accel</span></span></code></pre></div><h3 id="dynamic-modules" tabindex="-1">Dynamic Modules <a class="header-anchor" href="#dynamic-modules" aria-label="Permalink to &quot;Dynamic Modules&quot;">​</a></h3><p>일반적으로 모든 모듈은 단일 PX4 실행 파일로 컴파일됩니다. However, on Posix, there&#39;s the option of compiling a module into a separate file, which can be loaded into PX4 using the <code>dyn</code> command.</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dyn</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./test.px4mod</span></span></code></pre></div><h2 id="nuttx" tabindex="-1">NuttX <a class="header-anchor" href="#nuttx" aria-label="Permalink to &quot;NuttX&quot;">​</a></h2><p>NuttX has an integrated shell interpreter (<a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=139629410" target="_blank" rel="noreferrer">NuttShell (NSH)</a>), and thus scripts can be executed directly.</p><h3 id="시스템-부팅-디버깅" tabindex="-1">시스템 부팅 디버깅 <a class="header-anchor" href="#시스템-부팅-디버깅" aria-label="Permalink to &quot;시스템 부팅 디버깅&quot;">​</a></h3><p>소프트웨어 구성 요소의 드라이버 오류로 인하여 부팅이 중단되지는 않습니다. This is controlled via <code>set +e</code> in the startup script.</p><p>The boot sequence can be debugged by connecting the <a href="./../debug/system_console.html">system console</a> and power-cycling the board. 부팅 로그에는 부팅 순서에 대한 자세한 정보가 포함되어 있으며, 부팅 중단 이유에 대한 힌트가 포함되어 있습니다.</p><h4 id="일반적인-부팅-실패-사례" tabindex="-1">일반적인 부팅 실패 사례 <a class="header-anchor" href="#일반적인-부팅-실패-사례" aria-label="Permalink to &quot;일반적인 부팅 실패 사례&quot;">​</a></h4><ul><li>For custom applications: The system was out of RAM. Run the <code>free</code> command to see the amount of free RAM.</li><li>A software fault or assertion resulting in a stack trace</li></ul><h3 id="시스템-시작-변경" tabindex="-1">시스템 시작 변경 <a class="header-anchor" href="#시스템-시작-변경" aria-label="Permalink to &quot;시스템 시작 변경&quot;">​</a></h3><p>The whole boot can be replaced by creating a file <code>/etc/rc.txt</code> on the microSD card with a new configuration (nothing in the old configuration will be auto-started, and if the file is empty, nothing at all will be started).</p><p>Customizing the default boot is almost always a better approach. This is documented below.</p><h3 id="시스템-시작-사용자-정의" tabindex="-1">시스템 시작 사용자 정의 <a class="header-anchor" href="#시스템-시작-사용자-정의" aria-label="Permalink to &quot;시스템 시작 사용자 정의&quot;">​</a></h3><p>The best way to customize the system startup is to introduce a <a href="./../dev_airframes/adding_a_new_frame.html">new frame configuration</a>. The frame configuration file can be included in the firmware or on an SD Card.</p><p>If you only need to &quot;tweak&quot; the existing configuration, such as starting one more application or setting the value of a few parameters, you can specify these by creating two files in the <code>/etc/</code> directory of the SD Card:</p><ul><li><a href="#customizing-the-configuration-config-txt">/etc/config.txt</a>: modify parameter values</li><li><a href="#starting-additional-applications-extras-txt">/etc/extras.txt</a>: start applications</li></ul><p>The files are described below.</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>The system boot files are UNIX FILES which require UNIX LINE ENDINGS. Windows에서 편집하는 경우 적절한 편집기를 사용하여야 합니다.</p></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>These files are referenced in PX4 code as <code>/fs/microsd/etc/config.txt</code> and <code>/fs/microsd/etc/extras.txt</code>, where the root folder of the microsd card is identified by the path <code>/fs/microsd</code>.</p></div><h4 id="구성-사용자-정의-config-txt" tabindex="-1">구성 사용자 정의(config.txt) <a class="header-anchor" href="#구성-사용자-정의-config-txt" aria-label="Permalink to &quot;구성 사용자 정의(config.txt)&quot;">​</a></h4><p>The <code>config.txt</code> file can be used to modify parameters. It is loaded after the main system has been configured and <em>before</em> it is booted.</p><p>For example, you could create a file on the SD card, <code>etc/config.txt</code> with that sets parameter values as shown:</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">param</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> set-default</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> PWM_MAIN_DIS3</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">param</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> set-default</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> PWM_MAIN_MIN3</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1120</span></span></code></pre></div><h4 id="starting-additional-applications-extras-txt" tabindex="-1">Starting Additional Applications (extras.txt) <a class="header-anchor" href="#starting-additional-applications-extras-txt" aria-label="Permalink to &quot;Starting Additional Applications (extras.txt)&quot;">​</a></h4><p>The <code>extras.txt</code> can be used to start additional applications after the main system boot. 일반적으로, 페이로드 콘트롤러나 유사한 선택적 사용자 지정 구성 요소들입니다.</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>Calling an unknown command in system boot files may result in boot failure. 일반적으로 시스템은 부팅 실패 후 mavlink 메시지를 스트리밍하지 않습니다. 이 경우 시스템 콘솔에 인쇄된 오류 메시지를 확인하여야 합니다.</p></div><p>다음 예는 사용자 정의 애플리케이션 시작 방법을 설명합니다.</p><ul><li><p>Create a file on the SD card <code>etc/extras.txt</code> with this content:</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">custom_app</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> start</span></span></code></pre></div></li><li><p>A command can be made optional by gating it with the <code>set +e</code> and <code>set -e</code> commands:</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> +e</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">optional_app</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> start</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      # Will not result in boot failure if optional_app is unknown or fails</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -e</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mandatory_app</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> start</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     # Will abort boot if mandatory_app is unknown or fails</span></span></code></pre></div></li></ul>`,41)]))}const m=a(o,[["render",n]]);export{u as __pageData,m as default};
