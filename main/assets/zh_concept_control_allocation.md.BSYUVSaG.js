import{_ as a,a as t}from"./chunks/control_allocation_pipeline.BoExmcYK.js";import{_ as i,c as r,a8 as o,o as s}from"./chunks/framework.BDnHobkS.js";const g=JSON.parse('{"title":"控制分配 (混控)","description":"","frontmatter":{},"headers":[],"relativePath":"zh/concept/control_allocation.md","filePath":"zh/concept/control_allocation.md"}'),n={name:"zh/concept/control_allocation.md"};function l(h,e,p,c,d,m){return s(),r("div",null,e[0]||(e[0]=[o('<h1 id="控制分配-混控" tabindex="-1">控制分配 (混控) <a class="header-anchor" href="#控制分配-混控" aria-label="Permalink to &quot;控制分配 (混控)&quot;">​</a></h1><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Control allocation replaces the legacy mixing approach used in PX4 v1.13 and earlier. For PX4 v1.13 documentation see: <a href="https://docs.px4.io/v1.13/en/concept/mixing.html" target="_blank" rel="noreferrer">Mixing &amp; Actuators</a>, <a href="https://docs.px4.io/v1.13/en/concept/geometry_files.html" target="_blank" rel="noreferrer">Geometry Files</a> and <a href="https://docs.px4.io/v1.13/en/dev_airframes/adding_a_new_frame.html" target="_blank" rel="noreferrer">Adding a New Airframe Configuration</a>.</p></div><p>PX4从核心控制器获取所需的扭矩和推力指令，并将它们转换为控制电机或作动器的驱动指令。</p><p>指令间的转换取决于飞行器的物理构型。 例如，给“向右转”需要给出一个扭矩指令：</p><ul><li>对于每个副翼都有一个舵机的飞机来说，该指令将会控制一个舵机向高处偏转，另一个向低处偏转。</li><li>多旋翼将会通过改变所有电机的转速来向右偏航。</li></ul><p>PX4将这个转换逻辑区分开，这个逻辑被称为从姿态/角速率控制器输出的“混控”。 这样可以确保核心控制器不需要对每个机型构型进行特殊处理，可以大大提高复用性。</p><p>此外，PX4还将输出函数映射至指定的硬件输出。 这也意味着任何电机或舵机可以分配给几乎任何物理输出。</p><p><img src="'+a+'" alt="Mixing Overview"></p><h2 id="作动器控制流程" tabindex="-1">作动器控制流程 <a class="header-anchor" href="#作动器控制流程" aria-label="Permalink to &quot;作动器控制流程&quot;">​</a></h2><p>模块和uORB话题混控流程概览（点击全屏查看）：</p><p><img src="'+t+`" alt="Pipeline Overview"></p><p>备注：</p><ul><li>角速率控制器输出力矩和推力设定值</li><li>the <code>control_allocator</code> module: <ul><li>根据配置参数处理不同飞行器构型</li><li>进行混控计算</li><li>处理电机失效</li><li>发布电机和作动器控制信号</li><li>publishes the servo trims separately so they can be added as an offset when <a href="./../config/actuators.html#actuator-testing">testing actuators</a> (using the test sliders).</li></ul></li><li>输出驱动： <ul><li>处理硬件初始化和更新</li><li>use a shared library <a href="https://github.com/PX4/PX4-Autopilot/blob/main/src/lib/mixer_module/" target="_blank" rel="noreferrer">src/libs/mixer_module</a>. The driver defines a parameter prefix, e.g. <code>PWM_MAIN</code> that the library then uses for configuration. Its main task is to select from the input topics and assign the right data to the outputs based on the user set <code>&lt;param_prefix&gt;_FUNCx</code> parameter values. For example if <code>PWM_MAIN_FUNC3</code> is set to <strong>Motor 2</strong>, the 3rd output is set to the 2nd motor from <code>actuator_motors</code>.</li><li>output functions are defined under <a href="https://github.com/PX4/PX4-Autopilot/blob/main/src/lib/mixer_module/output_functions.yaml" target="_blank" rel="noreferrer">src/lib/mixer_module/output_functions.yaml</a>.</li></ul></li><li>if you want to control an output from MAVLink, set the relevant output function to <strong>Offboard Actuator Set x</strong>, and then send the <a href="https://mavlink.io/en/messages/common.html#MAV_CMD_DO_SET_ACTUATOR" target="_blank" rel="noreferrer">MAV_CMD_DO_SET_ACTUATOR</a> MAVLink command.</li></ul><h2 id="添加新构型或输出函数" tabindex="-1">添加新构型或输出函数 <a class="header-anchor" href="#添加新构型或输出函数" aria-label="Permalink to &quot;添加新构型或输出函数&quot;">​</a></h2><p>See <a href="https://github.com/PX4/PX4-Autopilot/commit/5cdb6fbd8e1352dcb94bd58918da405f8ff930d7" target="_blank" rel="noreferrer">this commit</a> for how to add a new geometry. The QGC UI will then automatically show the right configuration UI when <a href="./../advanced_config/parameter_reference.html#CA_AIRFRAME">CA_AIRFRAME</a> is set to the new geometry.</p><p><a href="https://github.com/PX4/PX4-Autopilot/commit/a65533b46986e32254b64b7c92469afb8178e370" target="_blank" rel="noreferrer">This commit</a> shows how to add a new output function. Any uORB topic can be subscribed and assigned to a function.</p><p>Note that parameters for control allocation are defined in <a href="https://github.com/PX4/PX4-Autopilot/blob/main/src/modules/control_allocator/module.yaml" target="_blank" rel="noreferrer">src/modules/control_allocator/module.yaml</a> The schema for this file is <a href="https://github.com/PX4/PX4-Autopilot/blob/main/validation/module_schema.yaml#L440=" target="_blank" rel="noreferrer">here</a> (in particular, search for the key <code>mixer:</code></p><h2 id="设置默认机型构型" tabindex="-1">设置默认机型构型 <a class="header-anchor" href="#设置默认机型构型" aria-label="Permalink to &quot;设置默认机型构型&quot;">​</a></h2><p>When <a href="./../dev_airframes/adding_a_new_frame.html">adding a new frame configuration</a>, set the appropriate <a href="./../advanced_config/parameter_reference.html#CA_AIRFRAME">CA_AIRFRAME</a> and other default mixer values for the geometry.</p><p>You can see this, for example, in the airframe configuration file <a href="https://github.com/PX4/PX4-Autopilot/blob/main/ROMFS/px4fmu_common/init.d/airframes/13200_generic_vtol_tailsitter" target="_blank" rel="noreferrer">13200_generic_vtol_tailsitter</a></p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">param</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> set-default</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> CA_AIRFRAME</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">param</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> set-default</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> CA_ROTOR_COUNT</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">param</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> set-default</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> CA_ROTOR0_KM</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -0.05</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">param</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> set-default</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> CA_ROTOR0_PY</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.2</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span></span></code></pre></div><h2 id="设置构型和输出" tabindex="-1">设置构型和输出 <a class="header-anchor" href="#设置构型和输出" aria-label="Permalink to &quot;设置构型和输出&quot;">​</a></h2><p>The broad geometry and default parameters for a vehicle are set (from the frame configuration file) when selecting the airframe in QGroundControl: <a href="./../config/airframe.html">Basic Configuration &gt; Airframe</a>.</p><p>The geometry parameters and output mapping for the specific frame and flight controller hardware are then configured using the QGroundControl <strong>Actuators</strong> setup screen: <a href="./../config/actuators.html">Basic Configuration &gt; Actuator Configuration and Testing</a>.</p>`,24)]))}const _=i(n,[["render",l]]);export{g as __pageData,_ as default};
