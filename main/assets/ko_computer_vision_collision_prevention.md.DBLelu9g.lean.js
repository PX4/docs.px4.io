import{_ as a,a as t,b as o,c as i}from"./chunks/obstacle_distance_def.COt6JW50.js";import{_ as n,c as r,a8 as s,o as l}from"./chunks/framework.BDnHobkS.js";const b=JSON.parse('{"title":"충돌 방지","description":"","frontmatter":{},"headers":[],"relativePath":"ko/computer_vision/collision_prevention.md","filePath":"ko/computer_vision/collision_prevention.md"}'),c={name:"ko/computer_vision/collision_prevention.md"};function d(h,e,m,p,f,u){return l(),r("div",null,e[0]||(e[0]=[s('<h1 id="충돌-방지" tabindex="-1">충돌 방지 <a class="header-anchor" href="#충돌-방지" aria-label="Permalink to &quot;충돌 방지&quot;">​</a></h1><p><em>Collision Prevention</em> may be used to automatically slow and stop a vehicle before it can crash into an obstacle. It can be enabled for multicopter vehicles when using acceleration-based <a href="./../flight_modes_mc/position.html">Position mode</a> (or VTOL vehicles in MC mode).</p><h2 id="개요" tabindex="-1">개요 <a class="header-anchor" href="#개요" aria-label="Permalink to &quot;개요&quot;">​</a></h2><p>The vehicle restricts the current velocity in order to slow down as it gets closer to obstacles and adapts the acceleration setpoint in order to disallow collision trajectories. 장애물에서 멀어지거나 평행하게 이동하려면 사용자는 기체를 장애물에 더 가깝게 만들지 않는 설정 값으로 이동하도록 명령하여야 합니다. 알고리즘은 &quot;더 나은&quot;설정점이 요청된 설정 값의 양쪽에있는 고정된 마진내에 존재한다고 판단되면 설정값 방향을 약간 조정합니다.</p><p>Collision prevention prevents motion in directions where no sensor data is available (i.e. if you have no rear-sensor data, you will not be able to fly backwards). It may also restrict vehicle maximum speed if the sensor range isn&#39;t large enough!</p><p>Multiple sensors can be used to get information about, and prevent collisions with, objects <em>around</em> the vehicle. If multiple sources supply data for the <em>same</em> orientation, the system uses the data that reports the smallest distance to an object.</p><p>The feature requires obstacle information from a <a href="./../sensor/rangefinders.html">distance sensor</a>. The sensor may be connected to the flight controller (recommended). It can also be used with distance information provided by an external system via MAVLink, but this is currently untested (see <a href="#companion">companion setup</a> below).</p><p>The <a href="#rangefinder">rangefinders</a> that have been tested when directly connected to PX4 are listed below, along with setup instructions. The <a href="#px4-configuration">PX4 Configuration</a> specific to collision-prevention is the same for all sensors and independent of whether data is provided by a connected sensor or MAVLink.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li>If high flight speeds are critical, consider disabling collision prevention when not needed.</li><li>Ensure that you have sensors/sensor data in all directions that you want to fly, including backwards (when collision prevention is enabled).</li></ul></div><h2 id="rangefinder" tabindex="-1">Supported Rangefinders <a class="header-anchor" href="#rangefinder" aria-label="Permalink to &quot;Supported Rangefinders {#rangefinder}&quot;">​</a></h2><p>Collision Prevention has been tested with the following rangefinders attached to PX4 (not for providing data <a href="#companion">supplied over MAVLink</a>).</p><h3 id="lanbao-psk-cm8jl65-cc5" tabindex="-1">Lanbao PSK-CM8JL65-CC5 <a class="header-anchor" href="#lanbao-psk-cm8jl65-cc5" aria-label="Permalink to &quot;Lanbao PSK-CM8JL65-CC5&quot;">​</a></h3><p>At time of writing PX4 allows you to use the <a href="./../sensor/cm8jl65_ir_distance_sensor.html">Lanbao PSK-CM8JL65-CC5</a> IR distance sensor for collision prevention &quot;out of the box&quot;, with minimal additional configuration:</p><ol><li><a href="./../sensor/cm8jl65_ir_distance_sensor.html">Attach and configure the sensor</a>.</li><li>Set the sensor orientation using <a href="./../advanced_config/parameter_reference.html#SENS_CM8JL65_R_0">SENS_CM8JL65_R_0</a>.</li><li><a href="#px4-configuration">Configure and enable collision prevention</a></li></ol><h3 id="lightware-lidar-sf45-rotating-lidar" tabindex="-1">LightWare LiDAR SF45 Rotating Lidar <a class="header-anchor" href="#lightware-lidar-sf45-rotating-lidar" aria-label="Permalink to &quot;LightWare LiDAR SF45 Rotating Lidar&quot;">​</a></h3><p>PX4 v1.14 (and later) supports the <a href="https://www.lightwarelidar.com/shop/sf45-b-50-m/" target="_blank" rel="noreferrer">LightWare LiDAR SF45</a> rotating lidar which provides 320 degree sensing.</p><p>The SF45 must be connected via a UART/serial port and configured as described below:</p><ol><li><p><a href="https://www.lightwarelidar.com/resources-software" target="_blank" rel="noreferrer">LightWare Studio</a> configuration:</p><ul><li>In the LightWare Studio app enable scanning, set the scan angle, and change the baud rate to <code>921600</code>.</li></ul></li><li><p>Add <a href="./../modules/modules_driver_distance_sensor.html#lightware-sf45-serial">lightware_sf45_serial</a> driver to PX4 firmware:</p><ol><li>Open <a href="./../hardware/porting_guide_config.html#px4-menuconfig-setup">menuconfig</a></li><li>Under <strong>drivers &gt; Distance sensors</strong> select <code>lightware_sf45_serial</code>.</li><li>Recompile and upload to the flight controller.</li></ol></li><li><p><a href="./../advanced_config/parameters.html">Set the following parameters</a> via QGC to configure the driver:</p><ul><li><a href="./../advanced_config/parameter_reference.html#SENS_EN_SF45_CFG">SENS_EN_SF45_CFG</a>: Set to the serial port you have the sensor connected to. Make sure GPS or Telemetry are not enabled on this port.</li><li><a href="./../advanced_config/parameter_reference.html#SF45_ORIENT_CFG">SF45_ORIENT_CFG</a>: Set the orientation of the sensor (facing up or down)</li><li><a href="./../advanced_config/parameter_reference.html#SF45_UPDATE_CFG">SF45_UPDATE_CFG</a>: Set the update rate</li><li><a href="./../advanced_config/parameter_reference.html#SF45_YAW_CFG">SF45_YAW_CFG</a>: Set the yaw orientation</li></ul></li><li><p><a href="#px4-configuration">Configure and enable collision prevention</a></p></li></ol><p>PX4 will emit the <a href="https://mavlink.io/en/messages/common.html#OBSTACLE_DISTANCE" target="_blank" rel="noreferrer">OBSTACLE_DISTANCE</a> message when collision prevention is enabled. In QGroundControl you should this in the <a href="./../debug/mavlink_shell.html#qgroundcontrol-mavlink-console">MAVLink console</a> if collision prevention is configured correctly and active.</p><p>The obstacle overlay in QGC will look like this:</p><p><img src="'+a+'" alt="sf45"></p><h3 id="other-rangefinders" tabindex="-1">Other Rangefinders <a class="header-anchor" href="#other-rangefinders" aria-label="Permalink to &quot;Other Rangefinders&quot;">​</a></h3><p>다른 센서를 활성화 할 수 있지만, 이를 위해서는 센서 방향과 시야를 설정하기 위하여 드라이버 코드를 수정하여야 합니다.</p><ul><li>Attach and configure the distance sensor on a particular port (see <a href="./../sensor/rangefinders.html">sensor-specific docs</a>) and enable collision prevention using <a href="#CP_DIST">CP_DIST</a>.</li><li>방향을 설정하려면 드라이버를 수정하십시오. This should be done by mimicking the <code>SENS_CM8JL65_R_0</code> parameter (though you might also hard-code the orientation in the sensor <em>module.yaml</em> file to something like <code>sf0x start -d ${SERIAL_DEV} -R 25</code> - where 25 is equivalent to <code>ROTATION_DOWNWARD_FACING</code>).</li><li>Modify the driver to set the <em>field of view</em> in the distance sensor UORB topic (<code>distance_sensor_s.h_fov</code>).</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>You can see the required modifications from the <a href="https://github.com/PX4/PX4-Autopilot/pull/12179" target="_blank" rel="noreferrer">feature PR</a>. 변경 사항에 기여하여 주십시오!</p></div><h2 id="px4-설정" tabindex="-1">PX4 설정 <a class="header-anchor" href="#px4-설정" aria-label="Permalink to &quot;PX4 설정&quot;">​</a></h2><p><em>Collision Prevention</em> is enabled on PX4 by <a href="./../advanced_config/parameters.html">setting the parameter</a> for minimum allowed approach distance in QGroundControl to a positive value (<a href="#CP_DIST">CP_DIST</a>). Note that this value is the distance to the sensors, not the outside of your vehicle or propellers (set a safe margin!).</p><p>In addition you will need to tune the <a href="#delay_tuning">sendor delay</a> and <a href="#angle_change_tuning">angle change tuning</a>. You may choose to enable <a href="#CP_GO_NO_DATA">CP_GO_NO_DATA</a> in order to allow unprotected movement in directions where there is no rangefinder data/sensor.</p><h3 id="delay_tuning" tabindex="-1">CP_DELAY Delay Tuning <a class="header-anchor" href="#delay_tuning" aria-label="Permalink to &quot;CP_DELAY Delay Tuning {#delay_tuning}&quot;">​</a></h3><p>There are two main sources of delay which should be accounted for: <em>sensor delay</em>, and vehicle <em>velocity setpoint tracking delay</em>. Both sources of delay are tuned using the <a href="#CP_DELAY">CP_DELAY</a> parameter.</p><p>The <em>sensor delay</em> for distance sensors connected directly to the flight controller can be assumed to be 0. 외부 비전 기반 시스템의 경우 센서 지연이 최대 0.2 초 일 수 있습니다.</p><p>Vehicle <em>velocity setpoint tracking delay</em> can be measured by flying at full speed in <a href="./../flight_modes_mc/position.html">Position mode</a>, then commanding a stop. 실제 속도와 속도 설정점 사이의 지연은 로그에서 측정할 수 있습니다. 추적 지연은 일반적으로 기체 크기와 튜닝에 따라 0.1 초에서 0.5 초 사이입니다.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>If vehicle speed oscillates as it approaches the obstacle (i.e. it slows down, speeds up, slows down) the delay is set too high.</p></div><h3 id="angle_change_tuning" tabindex="-1">CP_GUIDE_ANG Guidance Tuning <a class="header-anchor" href="#angle_change_tuning" aria-label="Permalink to &quot;CP_GUIDE_ANG Guidance Tuning {#angle_change_tuning}&quot;">​</a></h3><p>차량, 환경 유형 및 조종사의 기술에 따라 각기 다른 가이던스가 필요할 수 있습니다. Setting the <a href="#CP_GUIDE_ANG">CP_GUIDE_ANG</a> parameter to 0 will disable the guidance, resulting in the vehicle only moving exactly in the directions commanded. 이 매개 변수를 높이면 기체가 장애물을 피할 수 있는 최적의 방향을 선택할 수 있으므로 좁은 틈새를 더 쉽게 통과하고 물체를 돌아 다니는 동안 최소 거리를 정확하게 유지할 수 있습니다.</p><p>이 매개 변수가 너무 작으면 장애물에 가까워 졌을 때 기체가 &#39;고착&#39;된 느낌을 받을 수 있습니다. 장애물에서 멀어지는 이동만 허용되기 때문입니다. 매개 변수가 너무 크면 운전자가 지시하지 않은 방향으로 기체가 장애물에서 멀어지는 것처럼 느껴질 수 있습니다. 테스트에서 30도는 적절한 값이지만, 기체마다 값이 달라질 수 있습니다.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>The guidance feature will never direct the vehicle in a direction without sensor data. 단 하나의 거리 센서만 전방을 향하고 있는 상태에서 기체가 &#39;고착&#39;된 느낌이 드는 경우, 이는 정보 부족으로 인하여 가이던스가 방향을 안전하게 조정할 수 없기 때문일 수 있습니다.</p></div><h3 id="매개변수" tabindex="-1">매개변수 <a class="header-anchor" href="#매개변수" aria-label="Permalink to &quot;매개변수&quot;">​</a></h3><p>All relevant parameters are listed below:</p><table tabindex="0"><thead><tr><th>매개변수</th><th>설명</th></tr></thead><tbody><tr><td><a id="CP_DIST"></a><a href="./../advanced_config/parameter_reference.html#CP_DIST">CP_DIST</a></td><td>Minimum allowed distance from the sensor (the closest distance that the vehicle can approach the obstacle). Set negative to <em>disable</em> collision prevention.</td></tr><tr><td><a id="CP_DELAY"></a><a href="./../advanced_config/parameter_reference.html#CP_DELAY">CP_DELAY</a></td><td>Sensor and velocity setpoint tracking delay. See <a href="#delay_tuning">Delay Tuning</a> below.</td></tr><tr><td><a id="CP_GUIDE_ANG"></a><a href="./../advanced_config/parameter_reference.html#CP_GUIDE_ANG">CP_GUIDE_ANG</a></td><td>Angle (to both sides of the commanded direction) within which the vehicle may deviate if it finds fewer obstacles in that direction. See <a href="#angle_change_tuning">Guidance Tuning</a> below.</td></tr><tr><td><a id="CP_GO_NO_DATA"></a><a href="./../advanced_config/parameter_reference.html#CP_GO_NO_DATA">CP_GO_NO_DATA</a></td><td>Set to <code>1</code> to allow the vehicle to move in directions where there is no sensor coverage (default is 0/<code>False</code>).</td></tr><tr><td><a id="MPC_POS_MODE"></a><a href="./../advanced_config/parameter_reference.html#MPC_POS_MODE">MPC_POS_MODE</a></td><td>Set to <code>Acceleration based</code> (default). Collision prevention is disabled for <code>Direct velocity</code> and <code>Smoothed velocity</code>.</td></tr></tbody></table><h2 id="알고리즘-설명" tabindex="-1">알고리즘 설명 <a class="header-anchor" href="#알고리즘-설명" aria-label="Permalink to &quot;알고리즘 설명&quot;">​</a></h2><p>The data from all sensors are fused into an internal representation of 72 sectors around the vehicle, each containing either the sensor data and information about when it was last observed, or an indication that no data for the sector was available. When the vehicle is commanded to move in a particular direction, all sectors in the hemisphere of that direction are checked to see if the movement will bring the vehicle closer than allowed to any obstacles. 그러한 경우에는, 차량 속도가 제한됩니다.</p><p>The Algorithm then can be split intwo two parts, the constraining of the acceleration setpoint coming from the operator, and the compensation of the current velocity of the vehicle.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>If there is no sensor data in a particular direction, movement in that direction is restricted to 0 (preventing the vehicle from crashing into unseen objects). If you wish to move freely into directions without sensor coverage, this can be enabled by setting <a href="#CP_GO_NO_DATA">CP_GO_NO_DATA</a> to 1.</p></div><h3 id="acceleration-constraining" tabindex="-1">Acceleration Constraining <a class="header-anchor" href="#acceleration-constraining" aria-label="Permalink to &quot;Acceleration Constraining&quot;">​</a></h3><p>For this we split out Acceleration Setpoint into two components, one parallel to the closest distance to the obstacle and one normal to it. Then we scale each of these components according the the figure below. <img src="'+t+'" alt="Scalefactor"></p><h3 id="velocity-compensation" tabindex="-1">Velocity compensation <a class="header-anchor" href="#velocity-compensation" aria-label="Permalink to &quot;Velocity compensation&quot;">​</a></h3><p>This velocity restriction takes into account the <a href="./../config_mc/mc_jerk_limited_type_trajectory.html">jerk-optimal velocity controller</a> via <a href="./../advanced_config/parameter_reference.html#MPC_JERK_MAX">MPC_JERK_MAX</a> and <a href="./../advanced_config/parameter_reference.html#MPC_ACC_HOR">MPC_ACC_HOR</a>. Whereby The current velocity is compared with the maximum allowed velocity so that we are still able to break based on the maximal allowed jerk, acceleration and delay. from this we are able to use the proportional gain of the acceleration controller(<a href="./../advanced_config/parameter_reference.html#MPC_XY_VEL_P_ACC">MPC_XY_VEL_P_ACC</a>) to transform it into an acceleration.</p><h3 id="delay" tabindex="-1">Delay <a class="header-anchor" href="#delay" aria-label="Permalink to &quot;Delay&quot;">​</a></h3><p>The delay associated with collision prevention, both in the vehicle tracking velocity setpoints and in receiving sensor data from external sources, is conservatively estimated via the <a href="#CP_DELAY">CP_DELAY</a> parameter. This should be <a href="#delay_tuning">tuned</a> to the specific vehicle.</p><p>If the sectors adjacent to the commanded sectors are &#39;better&#39; by a significant margin, the direction of the requested input can be modified by up to the angle specified in <a href="#CP_GUIDE_ANG">CP_GUIDE_ANG</a>. 이는 장애물에 걸리지 않고 장애물 주변으로 차량을 &#39;안내&#39;하기 위하여 사용자 입력을 미세 조정하는 데 도움이 됩니다.</p><h3 id="범위-데이터-손실" tabindex="-1">범위 데이터 손실 <a class="header-anchor" href="#범위-데이터-손실" aria-label="Permalink to &quot;범위 데이터 손실&quot;">​</a></h3><p>If the autopilot does not receive range data from any sensor for longer than 0.5s, it will output a warning <em>No range data received, no movement allowed</em>. 이렇게하면 xy의 속도 설정값이 0이 됩니다. After 5 seconds of not receiving any data, the vehicle will switch into <a href="./../flight_modes_mc/hold.html">HOLD mode</a>. If you want the vehicle to be able to move again, you will need to disable Collision Prevention by either setting the parameter <a href="#CP_DIST">CP_DIST</a> to a negative value, or switching to a mode other than <a href="./../flight_modes_mc/position.html">Position mode</a> (e.g. to <em>Altitude mode</em> or <em>Stabilized mode</em>).</p><p>여러 센서가 연결되어 있고, 그 중 하나와의 연결이 끊어진 경우에도 보고 센서의 시야 (FOV) 내부를 비행할 수 있습니다. 결함이 있는 센서의 데이터가 만료되고, 이 센서가 포함하는 영역이 커버되지 않은 것으로 처리되므로 그 곳으로 이동할 수 없습니다.</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>Be careful when enabling <a href="#CP_GO_NO_DATA">CP_GO_NO_DATA=1</a>, which allows the vehicle to fly outside the area with sensor coverage. 여러 센서 중 하나라도 연결이 끊어지면 결함이있는 센서의 영역이 무시되어, 제약없이 이동할 수 있습니다.</p></div><h2 id="companion" tabindex="-1">Companion Setup <a class="header-anchor" href="#companion" aria-label="Permalink to &quot;Companion Setup {#companion}&quot;">​</a></h2><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>The companion implementation/setup is currently untested (the original companion project was unmaintained and has been archived).</p></div><p>If using a companion computer or external sensor, it needs to supply a stream of <a href="https://mavlink.io/en/messages/common.html#OBSTACLE_DISTANCE" target="_blank" rel="noreferrer">OBSTACLE_DISTANCE</a> messages, which should reflect when and where obstacle were detected.</p><p>The minimum rate at which messages <em>must</em> be sent depends on vehicle speed - at higher rates the vehicle will have a longer time to respond to detected obstacles. Initial testing of the system used a vehicle moving at 4 m/s with <code>OBSTACLE_DISTANCE</code> messages being emitted at 10Hz (the maximum rate supported by the vision system). 시스템은 상당히 빠른 속도와 낮은 주파수 거리 업데이트에서 잘 작동 할 수 있습니다.</p><h2 id="gazebo-simulation" tabindex="-1">Gazebo Simulation <a class="header-anchor" href="#gazebo-simulation" aria-label="Permalink to &quot;Gazebo Simulation&quot;">​</a></h2><p><em>Collision Prevention</em> can be tested using <a href="./../sim_gazebo_gz/">Gazebo</a> with the <a href="./../sim_gazebo_gz/vehicles.html#x500-quadrotor-with-2d-lidar">x500_lidar_2d</a> model. To do this, start a simulation with the x500 lidar model by running the following command:</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">make</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> px4_sitl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> gz_x500_lidar_2d</span></span></code></pre></div><p>Next, adjust the relevant parameters to the appropriate values and add arbitrary obstacles to your simulation world to test the collision prevention functionality.</p><p>The diagram below shows a simulation of collision prevention as viewed in Gazebo.</p><p><img src="'+o+'" alt="RViz image of collision detection using the x500lidar2d model in Gazebo"></p><h2 id="sensor-data-overview-implementation-details" tabindex="-1">Sensor Data Overview (Implementation Details) <a class="header-anchor" href="#sensor-data-overview-implementation-details" aria-label="Permalink to &quot;Sensor Data Overview (Implementation Details)&quot;">​</a></h2><p>Collision Prevention has an internal obstacle distance map that divides the plane around the drone into 72 Sectors. Internally this information is stored in the <a href="./../msg_docs/ObstacleDistance.html"><code>obstacle_distance</code></a> UORB topic. New sensor data is compared to the existing map, and used to update any sections that has changed.</p><p>The angles in the <code>obstacle_distance</code> topic are defined as follows:</p><p><img src="'+i+'" alt="ObstacleDistance Angles"></p><p>The data from rangefinders, rotary lidars, or companion computers, is processed differently, as described below.</p><h3 id="rotary-lidars" tabindex="-1">Rotary Lidars <a class="header-anchor" href="#rotary-lidars" aria-label="Permalink to &quot;Rotary Lidars&quot;">​</a></h3><p>Rotary Lidars add their data directly to the <a href="./../msg_docs/ObstacleDistance.html"><code>obstacle_distance</code></a> uORB topic.</p><h3 id="rangefinders" tabindex="-1">Rangefinders <a class="header-anchor" href="#rangefinders" aria-label="Permalink to &quot;Rangefinders&quot;">​</a></h3><p>Rangefinders publish their data to the <a href="./../msg_docs/DistanceSensor.html"><code>distance_sensor</code></a> uORB topic.</p><p>This data is then mapped onto the <code>obstacle_distance</code> topic. All sectors which have any overlap with the orientation (<code>orientation</code> and <code>q</code>) of the rangefinder, and the horizontal field of view (<code>h_fov</code>) are assigned that measurement value. For example, a distance sensor measuring from 9.99° to 10.01° the measurements will get added to the bin&#39;s corresponding to 5° and 10° covering the arc from 2.5° and 12.5°</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>the quaternion <code>q</code> is only used if the <code>orientation</code> is set to <code>ROTATION_CUSTOM</code>.</p></div><h3 id="보조-컴퓨터" tabindex="-1">보조 컴퓨터 <a class="header-anchor" href="#보조-컴퓨터" aria-label="Permalink to &quot;보조 컴퓨터&quot;">​</a></h3><p>Companion computers update the <code>obstacle_distance</code> topic using ROS2 or the <a href="https://mavlink.io/en/messages/common.html#OBSTACLE_DISTANCE" target="_blank" rel="noreferrer">OBSTACLE_DISTANCE</a> MAVLink message.</p>',78)]))}const v=n(c,[["render",d]]);export{b as __pageData,v as default};
