import{_ as a,c as e,o as t,ab as i}from"./chunks/framework.CUflZczI.js";const m=JSON.parse('{"title":"시스템 시작","description":"","frontmatter":{},"headers":[],"relativePath":"ko/concept/system_startup.md","filePath":"ko/concept/system_startup.md"}'),s={name:"ko/concept/system_startup.md"},o=i(`<h1 id="시스템-시작" tabindex="-1">시스템 시작 <a class="header-anchor" href="#시스템-시작" aria-label="Permalink to &quot;시스템 시작&quot;">​</a></h1><p>PX4 시작은 쉘 스크립트에 의해 제어됩니다. NuttX에서는 <a href="https://github.com/PX4/PX4-Autopilot/tree/master/ROMFS/px4fmu_common/init.d" target="_blank" rel="noreferrer">ROMFS/px4fmu_common/init.d</a> 폴더에 있습니다. 이 중 일부는 Posix(Linux/MacOS)에서도 사용됩니다. POSIX 전용 스크립트는 <a href="https://github.com/PX4/PX4-Autopilot/tree/master/ROMFS/px4fmu_common/init.d-posix" target="_blank" rel="noreferrer">ROMFS/px4fmu_common/init.d-posix</a> 폴더에 있습니다.</p><p>숫자와 밑줄로 시작하는 모든 파일(예: <code>10000_airplane</code>)은 기체 설정을 미리 정의합니다. 빌드시 기체 선택 UI에 대해 <a href="http://qgroundcontrol.com" target="_blank" rel="noreferrer">QGroundControl</a>에 의해 구문 분석되는 <code>airframes.xml</code> 파일로 내보내집니다. 새로운 구성을 추가하는 방법은 <a href="./../dev_airframes/adding_a_new_frame.html">여기</a>를 참고하십시오.</p><p>나머지 파일은 공통 시작 로직의 일부입니다. 첫 번째 실행 파일은 다른 모든 스크립트를 호출하는 <a href="https://github.com/PX4/PX4-Autopilot/blob/master/ROMFS/px4fmu_common/init.d/rcS" target="_blank" rel="noreferrer">init.d/rcS</a> 스크립트(또는 Posix의 경우 <a href="https://github.com/PX4/PX4-Autopilot/blob/master/ROMFS/px4fmu_common/init.d-posix/rcS" target="_blank" rel="noreferrer">init.d-posix/rcS</a>)입니다.</p><p>다음 섹션은 PX4가 실행되는 운영 체제에 따라 달라집니다.</p><h2 id="posix-linux-macos" tabindex="-1">POSIX (Linux/MacOS) <a class="header-anchor" href="#posix-linux-macos" aria-label="Permalink to &quot;POSIX (Linux/MacOS)&quot;">​</a></h2><p>Posix에서 시스템 셸은 스크립트 인터프리터로 사용됩니다(예: /bin/sh, Ubuntu에서 dash에 심볼릭 링크됨). 동작하기 위한 몇가지 조건이 있습니다.</p><ul><li>PX4 모듈은 시스템에서 개별적으로 실행할 수 있어야합니다. 이 동작은 심볼릭 링크로 처리합니다. 각 모듈에 대해 심볼릭 링크 <code>px4-&lt;module&gt; -&gt; px4</code>는 빌드 폴더의 <code>bin</code> 디렉토리에 생성됩니다. 실행시 바이너리 경로를 확인(<code>argv[0]</code>)하며, 모듈인 경우(<code>px4-</code>로 시작)에는 메인 px4 인스턴스(아래 참조)에 명령을 전송합니다.</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><code>px4-</code> 접두사는 시스템 명령(예: <code>shutdown</code>)과의 충돌을 피하기 위해 사용되며, <code>px4-&lt;TAB&gt;</code>를 입력하여 간단한 탭 완성을 사용할 수 있습니다. 이 방식으로 펌웨어를 다시 컴파일하지 않고 믹서 파일을 개별 설정할 수 있습니다.</p><ul><li>쉘은 심볼릭 링크를 찾을 위치를 알고 있어야 합니다. 이를 위하여, 기호 링크가 있는 <code>bin</code> 디렉토리가 시작 스크립트를 실행하기 직전에 <code>PATH</code> 변수에 추가됩니다.</li><li>쉘은 각 모듈을 새로운(클라이언트) 프로세스로 시작합니다. 각 클라이언트 프로세스는 실제 모듈이 스레드로 실행되는 px4(서버)의 기본 인스턴스와 통신합니다. 이 일련의 과정은 <a href="http://man7.org/linux/man-pages/man7/unix.7.html" target="_blank" rel="noreferrer">UNIX 소켓</a>으로 처리합니다. 서버는 클라이언트가 연결하고 명령을 보낼 수 있는 소켓으로 수신 대기합니다. 그런 다음 서버는 출력과 반환 코드를 다시 클라이언트로 전송합니다.</li><li>시작 스크립트는 <code>px4-</code> 접두어를 쓰지 않고, <code>commander start</code> 명령처럼 모듈을 직접 호출합니다. 이것은 alias를 사용하여 작동합니다. 각 모듈에 대해 <code>alias &lt;module&gt;=px4-&lt;module&gt;</code> 형식의 별칭이 <code>bin/px4-alias.sh</code> 파일에 생성됩니다.</li><li><code>rcS</code> 스크립트는 PX4 메인 인스턴스에서 실행됩니다. 모듈을 시작하지 않고, 먼저 <code>PATH</code> 변수를 업데이트한 다음 <code>rcS</code> 파일을 인수로 사용하여 셸을 실행합니다.</li><li>그 외에도, 다중 기체 시뮬레이션을 위하여 여러 서버 인스턴스를 시작할 수 있습니다. 클라이언트는 <code>--instance</code>로 인스턴스를 선택합니다. 인스턴스는 <code>$px4_instance</code> 변수를 통하여 스크립트에서 사용할 수 있습니다.</li></ul><p>모듈은 PX4가 시스템에서 실행 중이면, 터미널에서 실행할 수 있습니다. 예를 들어:</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">PX4-Autopilo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/build/px4_sitl_default/bin</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./px4-commander</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> takeoff</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./px4-listener</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sensor_accel</span></span></code></pre></div><h3 id="dynamic-modules" tabindex="-1">Dynamic Modules <a class="header-anchor" href="#dynamic-modules" aria-label="Permalink to &quot;Dynamic Modules&quot;">​</a></h3><p>일반적으로 모든 모듈은 단일 PX4 실행 파일로 컴파일됩니다. 그러나, POSIX에는 <code>dyn</code> 명령을 사용하여 PX4에 로드할 수 있는 별도의 파일로 모듈을 컴파일하는 옵션이 있습니다.</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dyn</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./test.px4mod</span></span></code></pre></div><h2 id="nuttx" tabindex="-1">NuttX <a class="header-anchor" href="#nuttx" aria-label="Permalink to &quot;NuttX&quot;">​</a></h2><p>NuttX에는 통합된 쉘 인터프리터(<a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=139629410" target="_blank" rel="noreferrer">NuttShell(NSH)</a>)에서 스크립트를 직접 실행할 수 있습니다.</p><h3 id="시스템-부팅-디버깅" tabindex="-1">시스템 부팅 디버깅 <a class="header-anchor" href="#시스템-부팅-디버깅" aria-label="Permalink to &quot;시스템 부팅 디버깅&quot;">​</a></h3><p>소프트웨어 구성 요소의 드라이버 오류로 인하여 부팅이 중단되지는 않습니다. 이것은 시작 스크립트에서 <code>set +e</code>를 통하여 제어됩니다.</p><p>부팅 순서는 <a href="./../debug/system_console.html">시스템 콘솔</a>을 연결하고, 보드의 전원을 껐다 켜서 디버깅할 수 있습니다. 부팅 로그에는 부팅 순서에 대한 자세한 정보가 포함되어 있으며, 부팅 중단 이유에 대한 힌트가 포함되어 있습니다.</p><h4 id="일반적인-부팅-실패-사례" tabindex="-1">일반적인 부팅 실패 사례 <a class="header-anchor" href="#일반적인-부팅-실패-사례" aria-label="Permalink to &quot;일반적인 부팅 실패 사례&quot;">​</a></h4><ul><li>For custom applications: The system was out of RAM. Run the <code>free</code> command to see the amount of free RAM.</li><li>A software fault or assertion resulting in a stack trace</li></ul><h3 id="시스템-시작-변경" tabindex="-1">시스템 시작 변경 <a class="header-anchor" href="#시스템-시작-변경" aria-label="Permalink to &quot;시스템 시작 변경&quot;">​</a></h3><p>The whole boot can be replaced by creating a file <code>/etc/rc.txt</code> on the microSD card with a new configuration (nothing in the old configuration will be auto-started, and if the file is empty, nothing at all will be started).</p><p>Customizing the default boot is almost always a better approach. This is documented below.</p><h3 id="시스템-시작-사용자-정의" tabindex="-1">시스템 시작 사용자 정의 <a class="header-anchor" href="#시스템-시작-사용자-정의" aria-label="Permalink to &quot;시스템 시작 사용자 정의&quot;">​</a></h3><p>The best way to customize the system startup is to introduce a <a href="./../dev_airframes/adding_a_new_frame.html">new frame configuration</a>. The frame configuration file can be included in the firmware or on an SD Card.</p><p>If you only need to &quot;tweak&quot; the existing configuration, such as starting one more application or setting the value of a few parameters, you can specify these by creating two files in the <code>/etc/</code> directory of the SD Card:</p><ul><li><a href="#customizing-the-configuration-config-txt">/etc/config.txt</a>: modify parameter values</li><li><a href="#starting-additional-applications-extras-txt">/etc/extras.txt</a>: start applications</li></ul><p>The files are described below.</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>시스템 부트 파일은 UNIX LINE ENDINGS가 필요한 UNIX FILES입니다. Windows에서 편집하는 경우 적절한 편집기를 사용하여야 합니다. 이 방식으로 펌웨어를 다시 컴파일하지 않고 믹서 파일을 개별 설정할 수 있습니다.</p><div class="info custom-block"><p class="custom-block-title">These files are referenced in PX4 code as <code>/fs/microsd/etc/config.txt</code> and <code>/fs/microsd/etc/extras.txt</code>, where the root folder of the microsd card is identified by the path <code>/fs/microsd</code>. 이 방식으로 펌웨어를 다시 컴파일하지 않고 믹서 파일을 개별 설정할 수 있습니다.</p><h4 id="구성-사용자-정의-config-txt" tabindex="-1">구성 사용자 정의(config.txt) <a class="header-anchor" href="#구성-사용자-정의-config-txt" aria-label="Permalink to &quot;구성 사용자 정의(config.txt)&quot;">​</a></h4><p>The <code>config.txt</code> file can be used to modify parameters. It is loaded after the main system has been configured and <em>before</em> it is booted.</p><p>For example, you could create a file on the SD card, <code>etc/config.txt</code> with that sets parameter values as shown:</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">param</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> set-default</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> PWM_MAIN_DIS3</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">param</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> set-default</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> PWM_MAIN_MIN3</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1120</span></span></code></pre></div><h4 id="starting-additional-applications-extras-txt" tabindex="-1">Starting Additional Applications (extras.txt) <a class="header-anchor" href="#starting-additional-applications-extras-txt" aria-label="Permalink to &quot;Starting Additional Applications (extras.txt)&quot;">​</a></h4><p><code>extras.txt</code>는 기본 시스템 부팅 후에, 추가로 애플리케이션을 시작할 수 있습니다. 일반적으로, 페이로드 콘트롤러나 유사한 선택적 사용자 지정 구성 요소들입니다.</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>시스템 부팅 파일에서 잘못된 명령을 실행하면, 부팅이 실패할 수 있습니다. 일반적으로 시스템은 부팅 실패 후 mavlink 메시지를 스트리밍하지 않습니다. 이 경우 시스템 콘솔에 인쇄된 오류 메시지를 확인하여야 합니다. 이 방식으로 펌웨어를 다시 컴파일하지 않고 믹서 파일을 개별 설정할 수 있습니다.</p><p>다음 예는 사용자 정의 애플리케이션 시작 방법을 설명합니다.</p><ul><li><p>다음 내용으로 SD 카드 <code>etc/extras.txt</code>에 파일을 생성합니다.</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">custom_app</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> start</span></span></code></pre></div></li><li><p><code>set +e</code>과 <code>set -e</code> 명령어를 사용하여 선택적으로 명령을 지정할 수 있습니다.</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> +e</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">optional_app</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> start</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      # Will not result in boot failure if optional_app is unknown or fails</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -e</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mandatory_app</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> start</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     # Will abort boot if mandatory_app is unknown or fails</span></span></code></pre></div></li></ul></div></div></div></div>`,9),n=[o];function l(r,c,p,d,h,u){return t(),e("div",null,n)}const g=a(s,[["render",l]]);export{m as __pageData,g as default};
