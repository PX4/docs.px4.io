import{_ as e,a,b as i,c as r,d as t,e as o,f as s,g as l,h as p,i as n}from"./chunks/esp8266_flashing_ftdi.Dp2hfL8u.js";import{_ as h,c,o as d,ab as m}from"./chunks/framework.CUflZczI.js";const E=JSON.parse('{"title":"ESP8266 WiFi 모듈","description":"","frontmatter":{},"headers":[],"relativePath":"ko/telemetry/esp8266_wifi_module.md","filePath":"ko/telemetry/esp8266_wifi_module.md"}'),g={name:"ko/telemetry/esp8266_wifi_module.md"},u=m('<h1 id="esp8266-wifi-모듈" tabindex="-1">ESP8266 WiFi 모듈 <a class="header-anchor" href="#esp8266-wifi-모듈" aria-label="Permalink to &quot;ESP8266 WiFi 모듈&quot;">​</a></h1><p>ESP8266와 유사품은 전체 TCP/IP와 마이크로 컨트롤러 기능을 제공하는 저렴한 Wi-Fi 모듈입니다. 모든 Pixhawk 시리즈 콘트롤러에서 사용 가능합니다.</p><div class="tip custom-block"><p class="custom-block-title">ESP8266은 <a href="./../flight_controller/pixracer.html">Pixracer</a>와 함께 사용되는 <em>실제적인</em> 기본 WiFi 모듈입니다 (일반적으로 번들로 함꼐 제공됨).</p></div><h2 id="구매처" tabindex="-1">구매처 <a class="header-anchor" href="#구매처" aria-label="Permalink to &quot;구매처&quot;">​</a></h2><p>ESP8266 모듈은 여러 곳에서 쉽게 구매할 수 있습니다. 몇 군데의 구매처는 아래에 나열되어 있습니다.</p><p>대부분의 모듈은 3.3V 입력 (전용)을 지원하지만 일부 비행 콘트롤러(예 : Pixhawk 4)는 5V에서 출력됩니다 (호환성을 확인하고 필요한 경우 전압을 낮추어야합니다).</p><p>3.3V 사용 모듈:</p><ul><li><a href="https://www.sparkfun.com/products/13678" target="_blank" rel="noreferrer">WRL-17146</a> (Sparkfun)</li><li><a href="https://us.gearbest.com/boards-shields/pp_009604906563.html" target="_blank" rel="noreferrer">AI 클라우드</a> - 단종됨 (GearBeast)</li></ul><p>5.0V 사용 모듈:</p><ul><li><a href="https://www.banggood.com/Wireless-Wifi-to-Uart-Telemetry-Module-With-Antenna-for-Mini-APM-Flight-Controller-p-1065339.html" target="_blank" rel="noreferrer">AI Thinker</a> (Banggood)</li><li><a href="https://www.banggood.com/MAVLink-Wifi-Bridge-2_4G-Wireless-Wifi-Telemetry-Module-with-Antenna-for-Pixhawk-APM-Flight-Controller-p-1428590.html" target="_blank" rel="noreferrer">AlphaUAVLink</a> (Banggood)</li></ul><p><a id="px4_config"></a></p><h2 id="pixhawk-px4-설정" tabindex="-1">Pixhawk/PX4 설정 <a class="header-anchor" href="#pixhawk-px4-설정" aria-label="Permalink to &quot;Pixhawk/PX4 설정&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>먼저 PX4 호환 ESP8266 펌웨어(<a href="#esp8266-flashing-firmware-advanced">아래 참조</a>)로 라디오를 <em>업데이트</em>할 수 있습니다. 제조 매뉴얼에 업데이트가 필요한 지 확인하십시오.</p></div><p>무료 UART에서 ESP8266을 Pixhawk 시리즈 비행 콘트롤러(예 : Pixracer)에 연결합니다.</p><p>USB로 비행 컨트롤러를 지상국에 연결합니다 (WiFi가 아직 완전히 설정되지 않았으므로).</p><p><em>QGroundControl</em> 사용법:</p><ul><li><a href="./../config/firmware.html">Load recent PX4 firmware onto the flight controller</a>.</li><li>ESP8266 연결용 <a href="./../peripherals/serial_configuration.html">직렬 포트를 설정</a>합니다. ESP8266에 설정된 값과 일치하려면 전송 속도를 921600으로 설정하여야 합니다.</li><li><a href="./../peripherals/mavlink_peripherals.html">Configure MAVLink</a> on the corresponding serial port in order to receive telemetry and transmit commands over the ESP8266.</li></ul><p>무선 연결용 비행 콘트롤러 직렬 포트를 설정후에는 지상국과 기체간의 물리적 USB 연결을 해제할 수 있습니다.</p><h2 id="esp8266을-통한-qgc-연결" tabindex="-1">ESP8266을 통한 QGC 연결 <a class="header-anchor" href="#esp8266을-통한-qgc-연결" aria-label="Permalink to &quot;ESP8266을 통한 QGC 연결&quot;">​</a></h2><p>이 모듈은 지상국과 기체 연결용 WiFi 핫스팟을 노출합니다.</p><div class="info custom-block"><p class="custom-block-title">The settings for the ESP8266 hotspot should be provided with the board (e.g. typically printed on the reverse side of the board or on the packaging).</p><p>일반적인 공장 네트워크 설정은 다음과 같습니다.</p><ul><li><strong>SSID:</strong> PixRacer</li><li><strong>비밀번호:</strong> pixracer</li><li><strong>WiFi Channel:</strong> 11</li><li><strong>UART 속도:</strong> 921600</li></ul><p>다른 모듈은 다음과 같은 설정을 사용할 수 있습니다.</p><ul><li><strong>SSID:</strong> IFFRC_xxxxxxxx</li><li><strong>비밀번호:</strong> 12345678</li><li><strong>IP:</strong> 192.168.4.1</li><li><strong>포트:</strong> 6789 (TCP)</li></ul><p>AlphaUILink 및 DOITING의 보드 예는 다음과 같습니다.</p><p><img src="'+e+'" width="250px" alt="AlphaUAVLink - 뒷면"> <img src="'+a+'" width="250px" alt="AlphaUAVLink - 앞면"> <img src="'+i+'" width="250px" alt="DOITING EPS 12F - 뒷면"> <img src="'+r+'" width="250px" alt="DOITING EPS 12F - 앞면"></p></div><p>Wi-Fi가 활성화된 <em>QGroundControl</em> 지상국 컴퓨터/태블릿에서 ESP8266용 무선 네트워크를 연결합니다. Windows 컴퓨터에서 이름이 <strong>Pixracer</strong>이고 암호가 <strong>pixracer</strong>인 네트워크 연결 설정은 다음과 같습니다.</p><p><img src="'+t+'" alt="Windows 네트워크 설정: 연결"> <img src="'+o+'" alt="Windows 네트워크 설정: 보안"></p><p><em>QGroundControl</em>은 지상국 컴퓨터가 &quot;Pixracer&quot;라는 이름의 WiFi에 연결되면 자동으로 기체에 연결됩니다.</p><p>다른 WiFi 이름을 가진 모듈을 사용하는 경우에는, 다음 섹션에 표시된대로 QGroundControl WiFi 연결을 수동으로 설정하여야 합니다.</p><h2 id="비표준-wifi-연결-qgc-설정" tabindex="-1">비표준 WiFi 연결 QGC 설정 <a class="header-anchor" href="#비표준-wifi-연결-qgc-설정" aria-label="Permalink to &quot;비표준 WiFi 연결 QGC 설정&quot;">​</a></h2><p><em>QGroundControl</em>은 지상국 컴퓨터가 &quot;Pixracer&quot;라는 이름의 WiFi에 연결되면 자동으로 기체에 연결됩니다. 다른 이름의 액세스 포인트에는 사용자 지정 통신 연결을 수동으로 생성하여야 합니다.</p><ol><li>Go to <a href="https://docs.qgroundcontrol.com/master/en/qgc-user-guide/settings_view/settings_view.html" target="_blank" rel="noreferrer">Application Settings &gt; Comm Links</a></li><li>적절한 설정으로 새 연결을 추가합니다.</li><li>새 연결을 선택하고, <strong>연결</strong>을 클릭합니다.</li><li>이제 기체에 연결되어야 합니다.</li></ol><h2 id="확인" tabindex="-1">확인 <a class="header-anchor" href="#확인" aria-label="Permalink to &quot;확인&quot;">​</a></h2><p>이제 무선 링크를 통해 QGC 컴퓨터에서 HUD 이동을 확인하고, ESP8266 WiFi 브리지에 대한 요약 패널을 볼 수 있습니다 (아래 그림 참조).</p><p><img src="'+s+'" alt="Wi-Fi 브리지 QGC 요약"></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>If you have any problem connecting, see <a href="https://docs.qgroundcontrol.com/master/en/qgc-user-guide/troubleshooting/qgc_usage.html" target="_blank" rel="noreferrer">QGC Usage Problems</a>.</p></div><h2 id="esp8266-플래싱-펌웨어-고급" tabindex="-1">ESP8266 플래싱/펌웨어 (고급) <a class="header-anchor" href="#esp8266-플래싱-펌웨어-고급" aria-label="Permalink to &quot;ESP8266 플래싱/펌웨어 (고급)&quot;">​</a></h2><p>다른 제조업체의 ESP8266 모듈에는 사전에 적절한 ESP8266 펌웨어가 설치되어 있지 않을 수 있습니다. 아래 지침은 적절한 버전으로 라디오를 업데이트 방법을 설명합니다.</p><h3 id="사전-빌드-바이너리" tabindex="-1">사전 빌드 바이너리 <a class="header-anchor" href="#사전-빌드-바이너리" aria-label="Permalink to &quot;사전 빌드 바이너리&quot;">​</a></h3><p><a href="http://www.grubba.com/mavesp8266/firmware-1.2.2.bin" target="_blank" rel="noreferrer">MavLink ESP8266 Firmware V 1.2.2</a></p><h3 id="소스-빌드" tabindex="-1">소스 빌드 <a class="header-anchor" href="#소스-빌드" aria-label="Permalink to &quot;소스 빌드&quot;">​</a></h3><p><a href="https://github.com/dogmaphobic/mavesp8266" target="_blank" rel="noreferrer">펌웨어 저장소</a>에는 ESP8266 펌웨어 빌드와 플래시 지침과 도구들이 있습니다.</p><h3 id="펌웨어-ota-업데이트" tabindex="-1">펌웨어 OTA 업데이트 <a class="header-anchor" href="#펌웨어-ota-업데이트" aria-label="Permalink to &quot;펌웨어 OTA 업데이트&quot;">​</a></h3><p>펌웨어 1.0.4 이상에서는 ESP의 <em>무선 업데이트</em> 기능을 사용하여 업데이트 가능합니다. AP WiFi 링크에 연결하고 <code>http://192.168.4.1/update</code>로 이동합니다. 위에서 다운로드한 펌웨어 파일을 WiFi 모듈에 업로드할 수 있습니다.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>이것은 펌웨어를 업데이트하는 가장 손쉬운 방법입니다.</p></div><h3 id="esp8266-펌웨어-플래싱" tabindex="-1">ESP8266 펌웨어 플래싱 <a class="header-anchor" href="#esp8266-펌웨어-플래싱" aria-label="Permalink to &quot;ESP8266 펌웨어 플래싱&quot;">​</a></h3><p>플래싱전에 아래 설명대로 <em>플래시 모드</em>에서 ESP8266을 부팅합니다. <a href="https://github.com/dogmaphobic/mavesp8266" target="_blank" rel="noreferrer">MavESP8266</a> 저장소를 복제한 경우 제공된 <a href="http://platformio.org" target="_blank" rel="noreferrer">PlatformIO</a> 도구 및 환경을 사용하여 펌웨어를 빌드하고 플래시할 수 있습니다. 위에서 사전 빌드 펌웨어를 다운로드한 경우에는 <a href="https://github.com/espressif/esptool" target="_blank" rel="noreferrer">esptool</a> 유틸리티를 다운로드후 아래 명령어를 실행하십시오.</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">esptool.py</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --baud</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 921600</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --port</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /dev/your_serial_port</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> write_flash</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0x00000</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> firmware_xxxxx.bin</span></span></code></pre></div><p>여기서:</p><ul><li><strong>firmware_xxxxx.bin</strong>은 위에서 다운로드 한 펌웨어입니다.</li><li><strong>your_serial_port</strong>는 ESP8266이 연결된 직렬 포트의 이름입니다 (예 : <code>/dev/cu.usbmodem</code>).</li></ul><h3 id="펌웨어-플래싱을-위한-배선" tabindex="-1">펌웨어 플래싱을 위한 배선 <a class="header-anchor" href="#펌웨어-플래싱을-위한-배선" aria-label="Permalink to &quot;펌웨어 플래싱을 위한 배선&quot;">​</a></h3><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>대부분의 ESP8266 모듈은 3.3V (전용)를 지원하지만, 일부 비행 콘트롤러(예 : Pixhawk 4)는 5V에서 출력됩니다. 호환성을 확인하고, 필요한 경우 전압을 낮추어야 합니다.</p></div><p>ESP8266을 <em>플래시 모드</em>로 설정하는 다양한 방법이 있지만, 모든 USB/UART 어댑터가 자동 모드 전환에 필요한 모든 핀을 제공하는 것은 아닙니다. <em>플래시 모드</em>에서 ESP8266을 부팅하려면, GPIO-0 핀을 로우(GND)로 설정하고 CH_PD 핀을 하이(VCC)로 설정합니다. 설정 예은 다음과 같습니다.</p><p><img src="'+l+'" alt="esp8266 깜박이는 장비"></p><p>RX, TX, VCC 및 GND가 FTDI 어댑터에서 ESP8266으로 연결되는 케이블을 직접 제작하였습니다. ESP8266에서 GPIO-0 및 CH_PD에 연결된 두 개의 와이어를 여분으로 남겨 두었습니다. 각각 GND 및 VCC에 연결하여 플래시 모드로 부팅 가능합니다.</p><h4 id="esp8266-esp-01-핀배열" tabindex="-1">ESP8266 (ESP-01) 핀배열 <a class="header-anchor" href="#esp8266-esp-01-핀배열" aria-label="Permalink to &quot;ESP8266 (ESP-01) 핀배열&quot;">​</a></h4><p><img src="'+p+'" alt="esp8266 wifi 모듈 핀배열"></p><h4 id="ftdi-usb-uart-어댑터를-사용한-플래싱-다이어그램" tabindex="-1">FTDI USB / UART 어댑터를 사용한 플래싱 다이어그램 <a class="header-anchor" href="#ftdi-usb-uart-어댑터를-사용한-플래싱-다이어그램" aria-label="Permalink to &quot;FTDI USB / UART 어댑터를 사용한 플래싱 다이어그램&quot;">​</a></h4><p><img src="'+n+'" alt="esp8266 플래싱"></p>',55),k=[u];function f(P,_,b,x,S,w){return d(),c("div",null,k)}const q=h(g,[["render",f]]);export{E as __pageData,q as default};
