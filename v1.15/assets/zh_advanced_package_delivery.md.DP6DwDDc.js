import{_ as o}from"./chunks/payload_delivery_mission_architecture.CMtMSIWz.js";import{_ as c,E as d,c as r,J as i,m as e,a as t,ab as p,o as l}from"./chunks/framework.CUflZczI.js";const P=JSON.parse('{"title":"包裹投递任务","description":"","frontmatter":{},"headers":[],"relativePath":"zh/advanced/package_delivery.md","filePath":"zh/advanced/package_delivery.md"}'),n={name:"zh/advanced/package_delivery.md"},s=e("h1",{id:"包裹投递任务",tabindex:"-1"},[t("包裹投递任务 "),e("a",{class:"header-anchor",href:"#包裹投递任务","aria-label":'Permalink to "包裹投递任务"'},"​")],-1),h=p('<p>包裹投递任务是航点任务的拓展，用户可以计划将包裹作为航点进行投递。</p><p>本节解释了包裹投递功能的架构。 它的目的是为从事扩展架构的开发者提供支持，例如支持新的有效载荷投递机制。</p><p>::: 信息 目前只有 <a href="./../peripherals/gripper.html">Glrippers</a> 可以用投递包裹。 绞盘尚未支持。 :::</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>关于如何设置包裹投递任务计划的详细文档可以在这里找到 <a href="./../flying/package_delivery_mission.html">here</a>。 <code>payload_deliverr</code> 模块的设置已包含在包裹投递机制的文档中，例如 <a href="./../peripherals/gripper.html#px4-configuration">Gripper</a></p></div><h2 id="包裹投递架构图" tabindex="-1">包裹投递架构图 <a class="header-anchor" href="#包裹投递架构图" aria-label="Permalink to &quot;包裹投递架构图&quot;">​</a></h2><p><img src="'+o+'" alt="包裹投递架构概述"></p><p>包裹投递功能围绕着 <a href="./../msg_docs/VehicleCommand.html">VehicleCommand</a> &amp; <a href="./../msg_docs/VehicleCommandAck.html">VehicleCommandAck</a> 消息。</p><p>中心思想是拥有一个处理 <code>DO_GRIPPER</code> 或 <code>DO_WINCH</code> 车辆命令的实体。 执行它并在确认成功投递时发送回确认。</p><p>因为 PX4 自动将 <code>VehicleCommand</code> uORB消息转播到一个用于 MAVLink 的 UART 端口，该端口被配置为 <a href="https://mavlink.io/en/messages/common.html#COMMAND_LONG" target="_blank" rel="noreferrer"><code>COMMAND_LONG</code></a> 消息， 外部有效载荷可以接收命令并执行它。</p><p>同样， 从 PX4 自动将 <a href="https://mavlink.io/en/messages/common.html#COMMAND_ACK" target="_blank" rel="noreferrer"><code>COMMAND_ACK</code></a> 来自外部来源的消息通过为 MAVLink 配置的 UART 端口传入到 <code>vehicle_command_ack</code> uORB 消息， PX4的 <code>navigator</code> 模块可以收到外部有效载荷对成功部署包的确认。</p><p>下面解释了包裹投递架构中涉及的每个实体。</p><h2 id="导航器" tabindex="-1">导航器 <a class="header-anchor" href="#导航器" aria-label="Permalink to &quot;导航器&quot;">​</a></h2><p>导航器处理接收车辆命令 ACK (下文所述)。 在收到成功部署确认消息后，它会设置任务块级别中的标志，以表示有效载荷部署已成功。</p><p>这允许任务安全地继续到下一个项目(例如路径点)，因为我们确信部署已成功得到确认。</p><h2 id="车辆命令-ack" tabindex="-1">车辆命令 ACK <a class="header-anchor" href="#车辆命令-ack" aria-label="Permalink to &quot;车辆命令 ACK&quot;">​</a></h2><p>我们正在等待来自内部的 ACK (通过 <code>payload_deliver</code> 模块)， 或外部(发送MAVLink消息的外部实体 <code>COMMAND_ACK</code>) 以确定包交付行动是否成功( <code>DO_GRIPPER</code> 或 <code>DO_WINCH</code>)。</p><h2 id="任务" tabindex="-1">任务 <a class="header-anchor" href="#任务" aria-label="Permalink to &quot;任务&quot;">​</a></h2><p>夹持器/绞盘命令被放置为一个<code>Mission Item</code>。 这是可能的，因为所有任务项目都有执行<code>MAV_CMD</code>（例如降落、起飞、航点等）的命令，可以设置为<code>DO_GRIPPER</code>或<code>DO_WINCH</code>。</p><p>在任务逻辑（上方的绿色框）中，如果到达夹持器/绞盘任务项目中的任一项，它将为旋翼飞行器（例如多轴飞行器）实现刹车保持功能（将下一个任务项目航点的<code>valid</code>标志设置为<code>false</code>），以便在执行部署时车辆将保持其位置。</p><p>固定翼飞机和其他车辆不考虑特殊制动条件。 所以如果你有一个固定翼的悬停任务，飞机在悬停的同时投递包裹，飞机不会停止 (因为这是不可能的)。</p><h2 id="任务块" tabindex="-1">任务块 <a class="header-anchor" href="#任务块" aria-label="Permalink to &quot;任务块&quot;">​</a></h2><p><code>MissionBlock</code>是<code>Mission</code>的父类，处理&quot;任务是否已完成？&quot;</p><p>这一切都在 <code>是指任务_item_reached_or_completed</code> 函数中执行，以处理时间延迟/任务项目的提升。</p><p>同时它实现了实际的issue_command函数，这将发布与任务项的 <code>MAV_CMD</code> 对应的机体命令，然后由外部有效载荷或内部的 <code>payload_deliverer</code> 模块接收。</p><h2 id="有效载荷投递" tabindex="-1">有效载荷投递 <a class="header-anchor" href="#有效载荷投递" aria-label="Permalink to &quot;有效载荷投递&quot;">​</a></h2><p>这是一个专用模块，用于处理夹具/绞盘支持，用于标准<a href="./../flying/package_delivery_mission.html">package delivery mission plan</a>。</p><p><code>payload_deliverer</code> 模块的设置已包含在设置实际包裹释放机制设置文档中，如 <a href="./../peripherals/gripper.html#px4-configuration">Gripper</a>.</p>',27);function _(m,f,k,u,g,v){const a=d("Badge");return l(),r("div",null,[s,i(a,{type:"tip",text:"PX4 v1.14"}),h])}const M=c(n,[["render",_]]);export{P as __pageData,M as default};
