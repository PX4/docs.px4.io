import{_ as e,c as a,o as t,ab as r}from"./chunks/framework.CUflZczI.js";const f=JSON.parse('{"title":"PX4 DroneCAN Firmware","description":"","frontmatter":{},"headers":[],"relativePath":"zh/dronecan/px4_cannode_fw.md","filePath":"zh/dronecan/px4_cannode_fw.md"}'),i={name:"zh/dronecan/px4_cannode_fw.md"},o=r(`<h1 id="px4-dronecan-firmware" tabindex="-1">PX4 DroneCAN Firmware <a class="header-anchor" href="#px4-dronecan-firmware" aria-label="Permalink to &quot;PX4 DroneCAN Firmware&quot;">​</a></h1><p>PX4 can run as the firmware on many DroneCAN peripherals. There are multiple benefits to this:</p><ul><li>PX4 has built-in drivers for a <a href="https://github.com/PX4/PX4-Autopilot/tree/release/1.15/src/drivers" target="_blank" rel="noreferrer">wide range</a> of sensors and peripherals components.</li><li>PX4 has a robust DroneCAN driver implementation that has undergone multiple years of field testing.</li><li>PX4 is continuously being developed. You routinely get access to the latest improvements.</li><li>PX4&#39;s estimation and control code makes it easy to create &quot;smart&quot; cannodes like integrated AHRS modules.</li><li>The firmware is completely open source (PX4 is BSD licensed).</li></ul><h2 id="building-the-firmware" tabindex="-1">Building the Firmware <a class="header-anchor" href="#building-the-firmware" aria-label="Permalink to &quot;Building the Firmware&quot;">​</a></h2><p>Follow the <a href="./../dev_setup/building_px4.html">PX4 building docs</a> just as you would to build firmware for a flight controller. Device build configurations are stored <a href="https://github.com/PX4/PX4-Autopilot/tree/release/1.15/boards" target="_blank" rel="noreferrer">here</a>. After installing the <a href="./../dev_setup/dev_env.html">PX4 toolchain</a>, clone the sources and build. For example, to build for the <a href="./ark_flow.html">Ark Flow</a> target:</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> clone</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --recursive</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://github.com/PX4/PX4-Autopilot</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> PX4-Autopilot</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">make</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ark_can-flow_default</span></span></code></pre></div><p>This will create an output in <strong>build/ark_can-flow_default</strong> named <strong>XX-X.X.XXXXXXXX.uavcan.bin</strong>. Follow the instructions at <a href="./#firmware-update">DroneCAN firmware update</a> to flash the firmware.</p><h2 id="developer-information" tabindex="-1">Developer Information <a class="header-anchor" href="#developer-information" aria-label="Permalink to &quot;Developer Information&quot;">​</a></h2><p>This section has information that is relevant to developers who want to add support for new DroneCAN hardware to the PX4 Autopilot.</p><h3 id="dronecan-bootloader-installation" tabindex="-1">DroneCAN Bootloader Installation <a class="header-anchor" href="#dronecan-bootloader-installation" aria-label="Permalink to &quot;DroneCAN Bootloader Installation&quot;">​</a></h3><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>DroneCAN devices typically ship with a bootloader pre-installed. Do not follow the instructions in this section unless you are developing DroneCAN devices, or have (accidentally) corrupted/wiped your bootloader.</p></div><p>The PX4 project includes a standard DroneCAN bootloader for STM32 devices.</p><p>The bootloader occupies the first 8-16 KB of flash, and is the first code executed on power-up. Typically the bootloader performs low-level device initialization, automatically determines the CAN bus baud rate, acts as a <a href="./#node-id-allocation">DroneCAN dynamic node ID client</a> to obtain a unique node ID, and waits for confirmation from the flight controller before proceeding with application boot.</p><p>This process ensures that a DroneCAN device can recover from invalid or corrupted application firmware without user intervention, and also permits automatic firmware updates.</p><p>Build the bootloader firmware by specifying the same peripheral target with the <code>canbootloader</code> build configuration instead of the <code>default</code> configuration.</p><p>For example, to build for the <a href="./ark_flow.html">Ark Flow</a> target:</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> clone</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --recursive</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://github.com/PX4/PX4-Autopilot</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> PX4-Autopilot</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">make</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ark_can-flow_canbootloader</span></span></code></pre></div><p>The binary can then be flashed to the microcontroller using your favorite SWD/JTAG debugger, such as the <a href="https://black-magic.org/index.html" target="_blank" rel="noreferrer">Black Magic Probe</a>, <a href="https://www.st.com/en/development-tools/st-link-v2.html" target="_blank" rel="noreferrer">ST-Link</a>, or <a href="https://www.segger.com/products/debug-probes/j-link/" target="_blank" rel="noreferrer">Segger JLink</a>.</p><h3 id="firmware-internals" tabindex="-1">Firmware Internals <a class="header-anchor" href="#firmware-internals" aria-label="Permalink to &quot;Firmware Internals&quot;">​</a></h3><p>For the most part, peripheral firmware works the same way as flight controller firmware builds. However, most modules are disabled - only the sensor drivers, DroneCAN driver, and internal infrastructure (uORB, etc.) are enabled.</p><p>DroneCAN communication is handled by the <a href="https://github.com/PX4/PX4-Autopilot/tree/release/1.15/src/drivers/uavcannode" target="_blank" rel="noreferrer">uavcannode</a> module. This driver handles producer-side communication - it takes sensor/actuator data from uORB, serializes it using the DroneCAN libraries, and publishes it over CAN. In the future, this will likely be merged with the <a href="https://github.com/PX4/PX4-Autopilot/tree/release/1.15/src/drivers/uavcan" target="_blank" rel="noreferrer">uavcan</a> module which handles flight controller side (consumer side) drivers, which receive/deserialize data from the CAN bus and publish them over uORB.</p><p>The build system also produces firmware binaries designed to be flashed through a DroneCAN bootloader via [PX4&#39;s DroneCAN flashing support] or the DroneCAN GUI, in addition to the standard raw binary, ELF, and <code>.px4</code> firmware files.</p>`,22),s=[o];function n(l,h,d,p,c,u){return t(),a("div",null,s)}const g=e(i,[["render",n]]);export{f as __pageData,g as default};
