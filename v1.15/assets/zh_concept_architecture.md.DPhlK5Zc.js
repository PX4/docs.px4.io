import{_ as e,a}from"./chunks/PX4_High-Level_Flight-Stack.ByVhe4zK.js";import{_ as s,c as t,o as i,ab as n}from"./chunks/framework.CUflZczI.js";const b=JSON.parse('{"title":"PX4 系统架构概述","description":"","frontmatter":{},"headers":[],"relativePath":"zh/concept/architecture.md","filePath":"zh/concept/architecture.md"}'),o={name:"zh/concept/architecture.md"},r=n('<h1 id="px4-系统架构概述" tabindex="-1">PX4 系统架构概述 <a class="header-anchor" href="#px4-系统架构概述" aria-label="Permalink to &quot;PX4 系统架构概述&quot;">​</a></h1><p>PX4 由两个主要部分组成：一是 <a href="#flight-stack">飞行控制栈（flight stack）</a> ，该部分主要包括状态估计和飞行控制系统；另一个是 <a href="#middleware">中间件</a> ，该部分是一个通用的机器人应用层，可支持任意类型的自主机器人，主要负责机器人的内部/外部通讯和硬件整合。</p><p>所有的 PX4 支持的 <a href="./../airframes/README.html">无人机机型</a> （包括其他诸如无人船、无人车、无人水下航行器等平台）均共用同一个代码库。 整个系统采用了 <a href="http://www.reactivemanifesto.org" target="_blank" rel="noreferrer">响应式（reactive）</a> 设计，这意味着：</p><ul><li>所有的功能都可以被分割成若干可替换、可重复使用的部件。</li><li>通过异步消息传递进行通信。</li><li>系统可以应对不同的工作负载。</li></ul><p><a id="architecture"></a></p><h2 id="顶层软件架构" tabindex="-1">顶层软件架构 <a class="header-anchor" href="#顶层软件架构" aria-label="Permalink to &quot;顶层软件架构&quot;">​</a></h2><p>下面的架构图对 PX4 的各个积木模块以及各模块之间的联系进行了一个详细的概述。 图的上半部分包括了中间件模块，而下半部分展示的则是飞行控制栈的组件。</p><p><img src="'+e+'" alt="PX4 架构"></p><p>源代码被拆分为许多相互独立的模块/程序 (图中使用 <code>monospace</code> 字体表示)。 通常来说一个图中的积木块对应一个功能模块。</p><p>上图中的箭头表示的是各个模块之间 <em>最重要的</em> 信息流连接。 实际运行时各模块之间信息流的连接数目比图中展示出来的要多很多，且部分数据（比如：配置参数）会被大部分模块访问。 For more information about each of these modules see the <a href="./../modules/modules_main.html">Modules &amp; Commands Reference</a>. :::</p><p>The arrows show the information flow for the <em>most important</em> connections between the modules. 使用 发布-订阅 消息总线这个方案意味着：</p><p>飞行控制栈是针对自主无人机设计的导航、制导和控制算法的集合。 它包括了为固定翼、旋翼和 VTOL 无人机设计的控制器，以及相应的姿态、位置估计器。</p><ul><li>系统是 “响应式” 的 — 系统异步运行，新数据抵达时系统立即进行更新。</li><li>系统所有的活动和通信都是完全并行的。</li><li>系统组件在任何地方都可以在保证线程安全的情况下使用数据。</li></ul><p>下图展示了飞行控制栈的整体架构， 下图展示了飞行控制栈的整体架构， 它包含了从传感器数据、 RC 控制量输入 到自主飞行控制（制导控制器，Navigator ），再到电机、舵机控制（执行器，Actuators）的全套通路。</p><h3 id="飞行控制栈" tabindex="-1">飞行控制栈 <a class="header-anchor" href="#飞行控制栈" aria-label="Permalink to &quot;飞行控制栈&quot;">​</a></h3><p>The flight stack is a collection of guidance, navigation and control algorithms for autonomous drones. It includes controllers for fixed-wing, multirotor and VTOL airframes as well as estimators for attitude and position.</p><p>The following diagram shows an overview of the building blocks of the flight stack. It contains the full pipeline from sensors, RC input and autonomous flight control (Navigator), down to the motor or servo control (Actuators).</p><p><img src="'+a+`" alt="PX4 High-Level Flight Stack"></p><p>An <strong>estimator</strong> takes one or more sensor inputs, combines them, and computes a vehicle state (for example the attitude from IMU sensor data).</p><p>A <strong>controller</strong> is a component that takes a setpoint and a measurement or estimated state (process variable) as input. Its goal is to adjust the value of the process variable such that it matches the setpoint. The output is a correction to eventually reach that setpoint. For example the position controller takes position setpoints as inputs, the process variable is the currently estimated position, and the output is an attitude and thrust setpoint that move the vehicle towards the desired position.</p><p>A <strong>mixer</strong> takes force commands (such as &quot;turn right&quot;) and translates them into individual motor commands, while ensuring that some limits are not exceeded. This translation is specific for a vehicle type and depends on various factors, such as the motor arrangements with respect to the center of gravity, or the vehicle&#39;s rotational inertia.</p><p><a id="middleware"></a></p><h3 id="中间件" tabindex="-1">中间件 <a class="header-anchor" href="#中间件" aria-label="Permalink to &quot;中间件&quot;">​</a></h3><p>The <a href="./../middleware/">middleware</a> consists primarily of device drivers for embedded sensors, communication with the external world (companion computer, GCS, etc.) and the uORB publish-subscribe message bus.</p><p>In addition, the middleware includes a <a href="./../simulation/">simulation layer</a> that allows PX4 flight code to run on a desktop operating system and control a computer modeled vehicle in a simulated &quot;world&quot;.</p><h2 id="更新速率" tabindex="-1">更新速率 <a class="header-anchor" href="#更新速率" aria-label="Permalink to &quot;更新速率&quot;">​</a></h2><p>Since the modules wait for message updates, typically the drivers define how fast a module updates. Most of the IMU drivers sample the data at 1kHz, integrate it and publish with 250Hz. Other parts of the system, such as the <code>navigator</code>, don&#39;t need such a high update rate, and thus run considerably slower.</p><p>The message update rates can be <a href="./../middleware/uorb.html">inspected</a> in real-time on the system by running <code>uorb top</code>.</p><p><a id="runtime-environment"></a></p><h2 id="运行时的环境" tabindex="-1">运行时的环境 <a class="header-anchor" href="#运行时的环境" aria-label="Permalink to &quot;运行时的环境&quot;">​</a></h2><p>PX4 runs on various operating systems that provide a POSIX-API (such as Linux, macOS, NuttX or QuRT). It should also have some form of real-time scheduling (e.g. FIFO).</p><p>The inter-module communication (using <a href="./../middleware/uorb.html">uORB</a>) is based on shared memory. The whole PX4 middleware runs in a single address space, i.e. memory is shared between all modules.</p><div class="info custom-block"><p class="custom-block-title">The system is designed such that with minimal effort it would be possible to run each module in separate address space (parts that would need to be changed include <code>uORB</code>, <code>parameter interface</code>, <code>dataman</code> and <code>perf</code>).</p></div><p>There are 2 different ways that a module can be executed:</p><ul><li><p><strong>任务 （Tasks）</strong>: 模块在它自己的任务中运行, 具有自己的堆栈和进程优先级（这是更常见的方法）。</p></li><li><p><strong>Note</strong> 在工作队列中的任务不会显示在 <code>top</code> 中（你尽能看见工作队列本身，比如 <code>lpwork</code>）。</p><ul><li>All the tasks must behave co-operatively as they cannot interrupt each other.</li><li>Multiple <em>work queue tasks</em> can run on a queue, and there can be multiple queues.</li><li>A <em>work queue task</em> is scheduled by specifying a fixed time in the future, or via uORB topic update callback.</li></ul><p>The advantage of running modules on a work queue is that it uses less RAM, and potentially results in fewer task switches. The disadvantages are that <em>work queue tasks</em> are not allowed to sleep or poll on a message, or do blocking IO (such as reading from a file). Long-running tasks (doing heavy computation) should potentially also run in a separate task or at least a separate work queue.</p></li></ul><div class="info custom-block"><p class="custom-block-title">Tasks running on a work queue do not show up in <a href="./../modules/modules_command.html#top"><code>top</code></a> (only the work queues themselves can be seen - e.g. as <code>wq:lp_default</code>). Use <a href="./../modules/modules_system.html#work-queue"><code>work_queue status</code></a> to display all active work queue items.</p></div><h3 id="后台任务" tabindex="-1">后台任务 <a class="header-anchor" href="#后台任务" aria-label="Permalink to &quot;后台任务&quot;">​</a></h3><p><code>px4_task_spawn_cmd()</code> is used to launch new tasks (NuttX) or threads (POSIX - Linux/macOS) that run independently from the calling (parent) task:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">independent_task </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> px4_task_spawn_cmd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;commander&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                    // 进程名称</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    SCHED_DEFAULT,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                  // 调度类型（RR 或 FIFO）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    SCHED_PRIORITY_DEFAULT </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 40</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 调度优先级</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    3600</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                           // 新任务或线程的堆栈大小</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    commander_thread_main,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 任务（或线程的主函数）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">argv[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Void 指针传递到新任务</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                                    // （这里是命令行参数）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    );</span></span></code></pre></div><h3 id="操作系统相关的信息" tabindex="-1">操作系统相关的信息 <a class="header-anchor" href="#操作系统相关的信息" aria-label="Permalink to &quot;操作系统相关的信息&quot;">​</a></h3><h4 id="nuttx" tabindex="-1">NuttX <a class="header-anchor" href="#nuttx" aria-label="Permalink to &quot;NuttX&quot;">​</a></h4><p><a href="https://nuttx.apache.org//" target="_blank" rel="noreferrer">NuttX</a> is the primary RTOS for running PX4 on a flight-control board. It is open source (BSD license), light-weight, efficient and very stable.</p><p>Modules are executed as tasks: they have their own file descriptor lists, but they share a single address space. A task can still start one or more threads that share the file descriptor list.</p><p>Each task/thread has a fixed-size stack, and there is a periodic task which checks that all stacks have enough free space left (based on stack coloring).</p><h4 id="linux-macos" tabindex="-1">Linux/MacOS <a class="header-anchor" href="#linux-macos" aria-label="Permalink to &quot;Linux/MacOS&quot;">​</a></h4><p>On Linux or macOS, PX4 runs in a single process, and the modules run in their own threads (there is no distinction between tasks and threads as on NuttX).</p>`,46),l=[r];function h(d,p,c,u,m,k){return i(),t("div",null,l)}const y=s(o,[["render",h]]);export{b as __pageData,y as default};
