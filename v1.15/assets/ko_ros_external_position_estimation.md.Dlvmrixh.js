import{_ as s}from"./chunks/ekf2_ev_delay_tuning.Bgxz8N1S.js";import{_ as i}from"./chunks/ref_frames.C52lwBbQ.js";import{_ as n,c as o,m as e,a as t,ab as a,o as r}from"./chunks/framework.CUflZczI.js";const w=JSON.parse('{"title":"위치 추정을 위한 비전 또는 모션 캡처 사용","description":"","frontmatter":{},"headers":[],"relativePath":"ko/ros/external_position_estimation.md","filePath":"ko/ros/external_position_estimation.md"}'),l={name:"ko/ros/external_position_estimation.md"},d=a('<h1 id="위치-추정을-위한-비전-또는-모션-캡처-사용" tabindex="-1">위치 추정을 위한 비전 또는 모션 캡처 사용 <a class="header-anchor" href="#위치-추정을-위한-비전-또는-모션-캡처-사용" aria-label="Permalink to &quot;위치 추정을 위한 비전 또는 모션 캡처 사용&quot;">​</a></h1><p>전역 위치 소스를 사용할 수 없거나 신뢰할 수 없는 경우(예: 실내나 다리 아래를 비행시)에, VIO(Visual Inertial Odometry) 및 MoCap(모션 캡처) 시스템을 사용하여 차량 내비게이션이 가능합니다.</p><p>VIO와 MoCap은 모두 &quot;시각적&quot; 정보에서 차량의 <em>포즈</em>(위치 및 자세)를 결정합니다. 그들 사이의 주요 차이점은 프레임 관점입니다.</p><ul><li>VIO는 <em>온보드 센서</em>를 사용하여 차량의 관점에서 포즈 데이터를 얻습니다(<a href="https://en.wikipedia.org/wiki/Visual_odometry#Egomotion" target="_blank" rel="noreferrer">egomotion</a> 참조).</li><li>MoCap은 <em>오프보드 카메라</em> 시스템을 사용하여, 3차원 공간에서 차량 포즈 데이터를 얻습니다(즉, 차량의 자세를 알려주는 외부 시스템임).</li></ul><p>두 시스템 유형의 포즈 데이터를 사용하여 PX4 자동조종장치의 로컬 위치 추정값(로컬 원점 기준)을 업데이트할 수 있으며, 선택적으로 차량 자세 추정을 융합할 수 있습니다. 또한 외부 포즈 시스템이 선형 속도 측정을 제공하는 경우에는 상태 추정 개선에 사용할 수 있습니다(선속도 측정의 융합은 EKF2에서만 지원됨).</p><p>PX4 기반 시스템을 구성하여 MoCap/VIO 시스템(ROS 또는 일부 다른 MAVLink 시스템을 통해)에서 데이터를 가져오는 방법과 보다 구체적으로 VICON 및 Optitrack과 같은 MoCap 시스템과 <a href="https://github.com/ethz-asl/rovio" target="_blank" rel="noreferrer">ROVIO</a>, <a href="https://github.com/uzh-rpg/rpg_svo" target="_blank" rel="noreferrer">SVO</a> 및 <a href="https://github.com/ethz-asl/ethzasl_ptam" target="_blank" rel="noreferrer">PTAM</a>과 같은 비전 기반 추정 시스템을 설정하는 방법을 설명합니다.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>The instructions differ depending on whether you are using the EKF2 or LPE estimator.</p></div><h2 id="px4-mavlink-통합" tabindex="-1">PX4 MAVLink 통합 <a class="header-anchor" href="#px4-mavlink-통합" aria-label="Permalink to &quot;PX4 MAVLink 통합&quot;">​</a></h2><p>PX4는 외부 위치 정보를 얻기 위하여, 다음 MAVLink 메시지를 사용하고 이를 <a href="./../middleware/uorb.html">uORB 주제</a>에 매핑합니다.</p><table><thead><tr><th>MAVLink</th><th>uORB</th></tr></thead><tbody><tr><td><a href="https://mavlink.io/en/messages/common.html#VISION_POSITION_ESTIMATE" target="_blank" rel="noreferrer">VISION_POSITION_ESTIMATE</a></td><td><code>vehicle_visual_odometry</code></td></tr><tr><td><a href="https://mavlink.io/en/messages/common.html#ODOMETRY" target="_blank" rel="noreferrer">ODOMETRY</a> (<code>frame_id =</code> <a href="https://mavlink.io/en/messages/common.html#MAV_FRAME_LOCAL_FRD" target="_blank" rel="noreferrer">MAV_FRAME_LOCAL_FRD</a>)</td><td><code>vehicle_visual_odometry</code></td></tr><tr><td><a href="https://mavlink.io/en/messages/common.html#ATT_POS_MOCAP" target="_blank" rel="noreferrer">ATT_POS_MOCAP</a></td><td><code>vehicle_mocap_odometry</code></td></tr><tr><td><a href="https://mavlink.io/en/messages/common.html#ODOMETRY" target="_blank" rel="noreferrer">ODOMETRY</a> (<code>frame_id =</code> <a href="https://mavlink.io/en/messages/common.html#MAV_FRAME_MOCAP_NED" target="_blank" rel="noreferrer">MAV_FRAME_MOCAP_NED</a>)</td><td><code>vehicle_mocap_odometry</code></td></tr></tbody></table><p>EKF2는 <code>vehicle_visual_odometry</code> 주제만 구독하므로, 처음 두 메시지만 처리할 수 있습니다. MoCap 시스템은 EKF2와 함께 작동하기 위해 이러한 메시지를 생성하여야 합니다. 주행 거리 측정 메시지는 선형 속도도 PX4로 전송 가능한 유일한 메시지입니다. LPE 추정기는 두 주제를 모두 구독하므로, 위의 모든 메시지를 처리할 수 있습니다.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>EFK2는 PX4에서 사용하는 기본 추정기입니다. LPE보다 테스트 및 지원이 더 잘 되므로, 우선적으로 사용하여야 합니다.</p></div><p>메시지는 30Hz(공분산을 포함하는 경우)와 50Hz 사이에서 스트리밍되어야 합니다. 메시지 비율이 너무 낮으면, EKF2가 외부 비전 메시지를 융합하지 않습니다.</p><p>다음의 MAVLink &quot;비전&quot; 메시지는 현재 PX4에서 지원되지 않습니다: <a href="https://mavlink.io/en/messages/common.html#GLOBAL_VISION_POSITION_ESTIMATE" target="_blank" rel="noreferrer">GLOBAL_VISION_POSITION_ESTIMATE</a>, <a href="https://mavlink.io/en/messages/common.html#VISION_SPEED_ESTIMATE" target="_blank" rel="noreferrer">VISION_SPEED_ESTIMATE</a>, <a href="https://mavlink.io/en/messages/common.html#VICON_POSITION_ESTIMATE" target="_blank" rel="noreferrer">VICON_POSITION_ESTIMATE</a></p><h2 id="기준-프레임" tabindex="-1">기준 프레임 <a class="header-anchor" href="#기준-프레임" aria-label="Permalink to &quot;기준 프레임&quot;">​</a></h2><p>PX4는 기준 프레임뿐만 아니라 로컬 바디 프레임에도 FRD(X <strong>F</strong>앞, Y<strong>R</strong>오른쪽 및 Z<strong>D</strong>자신)를 사용합니다. 자력계의 방향을 사용할 때 PX4 기준 좌표계 x 축은 북쪽과 정렬되며, 따라서 NED(X <strong>N</strong> orth, Y <strong>E</strong>ast, Z <strong>D</strong>own)라고 합니다. 대부분의 경우 PX4 추정기의 기준 좌표계와 외부 포즈 추정 중 하나가 일치하지 않습니다. 따라서 외부 포즈 추정의 기준 프레임은 다르게 명명되며 <a href="https://mavlink.io/en/messages/common.html#MAV_FRAME_LOCAL_FRD" target="_blank" rel="noreferrer">MAV_FRAME_LOCAL_FRD</a>라고 합니다.</p><p>기준 프레임의 소스에 따라 MAVLink Vision/MoCap 메시지를 보내기 전에, 포즈 추정값에 사용자 정의 변환을 적용하여야 합니다. 이것은 PX4 규칙에 맞도록 포즈 추정의 상위 및 하위 프레임 방향을 변경하는 데 필요합니다. 필요한 변환을 위해 MAVROS <a href="https://github.com/mavlink/mavros/blob/master/mavros_extras/src/plugins/odom.cpp" target="_blank" rel="noreferrer"><em>odom</em> 플러그인</a>을 살펴보십시오.</p><div class="tip custom-block"><p class="custom-block-title">ROS</p><p>사용자는 아래 <a href="#reference-frames-and-ros">참조 프레임 및 ROS</a>을 참고하십시오.</p></div>',18),c=e("em",null,"x",-1),h=e("em",null,"z",-1),m={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},p={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.025ex"},xmlns:"http://www.w3.org/2000/svg",width:"1.294ex",height:"1.025ex",role:"img",focusable:"false",viewBox:"0 -442 572 453","aria-hidden":"true"},_=a('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z" style="stroke-width:3;"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(572,0)"></g></g></g>',1),g=[_],f=e("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("mi",null,"x"),e("mrow",{"data-mjx-texclass":"ORD"})])],-1),u={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},k={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.025ex"},xmlns:"http://www.w3.org/2000/svg",width:"1.052ex",height:"1.025ex",role:"img",focusable:"false",viewBox:"0 -442 465 453","aria-hidden":"true"},b=a('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z" style="stroke-width:3;"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(465,0)"></g></g></g>',1),E=[b],v=e("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("mi",null,"z"),e("mrow",{"data-mjx-texclass":"ORD"})])],-1),O=e("em",null,"y",-1),P=a(`<p><code>x_{mav}</code>, <code>y_{mav}</code>, <code>z_{mav}</code>가 MAVLink를 통해 위치 피드백으로 전송되는 좌표라면, 결과는 다음과 같습니다.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>x_{mav} = x_{mocap}</span></span>
<span class="line"><span>y_{mav} = z_{mocap}</span></span>
<span class="line"><span>z_{mav} = - y_{mocap}</span></span></code></pre></div><p>방향과 관련하여 쿼터니언의 스칼라 부분 <em>w</em>을 동일하게 유지하고, 같은 방식으로 벡터 부분 <em>x</em>, <em>y</em> 및 <em>z</em>를 변경합니다. 이 트릭을 모든 시스템에 적용할 수 있습니다. NED 프레임을 가져와야 하는 경우 MoCap 출력을 보고 그에 따라 축을 교체하십시오.</p><h2 id="ekf2-튜닝과-설정" tabindex="-1">EKF2 튜닝과 설정 <a class="header-anchor" href="#ekf2-튜닝과-설정" aria-label="Permalink to &quot;EKF2 튜닝과 설정&quot;">​</a></h2><p>참고: 간략한 개요입니다. 자세한 내용은 <a href="./../advanced_config/tuning_the_ecl_ekf.html">EKF2 튜닝 가이드</a>를 참고하십시오.</p><p>EKF2와 함께 외부 위치 정보를 사용하려면, 다음 매개변수를 설정하여야 합니다. <em>QGroundControl</em> &gt; <strong>차량 설정 &gt; 매개변수 &gt; EKF2</strong>에서 설정할 수 있습니다.</p><table><thead><tr><th>매개변수</th><th>외부 위치 추정 설정</th></tr></thead><tbody><tr><td><a href="./../advanced_config/parameter_reference.html#EKF2_EV_CTRL">EKF2_EV_CTRL</a></td><td>Set <em>horizontal position fusion</em>, <em>vertical vision fusion</em>, <em>velocity fusion</em>, and <em>yaw fusion</em>, according to your desired fusion model.</td></tr><tr><td><a href="./../advanced_config/parameter_reference.html#EKF2_HGT_REF">EKF2_HGT_REF</a></td><td>Set to <em>Vision</em> to use the vision as the reference source for altitude estimation.</td></tr><tr><td><a href="./../advanced_config/parameter_reference.html#EKF2_EV_DELAY">EKF2_EV_DELAY</a></td><td>측정 타임스탬프와 &quot;실제&quot; 캡처 시간 간의 차이로 설정합니다. 자세한 정보는 <a href="#tuning-EKF2_EV_DELAY">아래</a>를 참고하십시오.</td></tr><tr><td><a href="./../advanced_config/parameter_reference.html#EKF2_EV_POS_X">EKF2_EV_POS_X</a>, <a href="./../advanced_config/parameter_reference.html#EKF2_EV_POS_Y">EKF2_EV_POS_Y</a>, <a href="./../advanced_config/parameter_reference.html#EKF2_EV_POS_Z">EKF2_EV_POS_Z</a></td><td>로봇의 몸체 프레임을 기준으로 비전 센서(또는 MoCap 마커)의 위치를 설정합니다.</td></tr></tbody></table><p>You can also disable GNSS, baro and range finder fusion using <a href="./../advanced_config/parameter_reference.html#EKF2_GPS_CTRL">EKF2_GPS_CTRL</a>, <a href="./../advanced_config/parameter_reference.html#EKF2_BARO_CTRL">EKF2_BARO_CTRL</a> and <a href="./../advanced_config/parameter_reference.html#EKF2_RNG_CTRL">EKF2_RNG_CTRL</a>, respectively.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>매개변수 변경 사항을 적용하려면, 비행 콘트롤러를 재부팅하십시오.</p></div><p><a id="tuning-EKF2_EV_DELAY"></a></p><h4 id="ekf2-ev-delay-튜닝" tabindex="-1">EKF2_EV_DELAY 튜닝 <a class="header-anchor" href="#ekf2-ev-delay-튜닝" aria-label="Permalink to &quot;EKF2_EV_DELAY 튜닝&quot;">​</a></h4><p><a href="./../advanced_config/parameter_reference.html#EKF2_EV_DELAY">EKF2_EV_DELAY</a>는 <em>IMU 측정에 대한 Vision Position Estimator 지연</em>입니다.</p><p>즉, 비전 시스템 타임스탬프와 IMU 시계(EKF2의 &quot;기본 시계&quot;)에 의해 기록되었을 &quot;실제&quot; 캡처 시간 간의 차이입니다.</p><p>기술적으로, 이것은 MoCap과 (예를 들어) ROS 컴퓨터 사이에 정확한 타임스탬프 (도착 시간이 아님)와 시간 동기화 (예 : NTP)가있는 경우 0으로 설정할 수 있습니다. 실제로는, 이것은 전체 MoCap-&gt;PX4 체인의 지연이 설정에 따라 매우 다르므로, 약간의 경험적 튜닝이 요구됩니다. 시스템이 완전히 동기화된 체인으로 설정되는 경우는 매우 드뭅니다.</p><p>IMU 속도와 EV 속도 간의 오프셋을 확인하여, 로그에서 대략적인 지연 추정치를 계산할 수 있습니다. EV 속도 로깅을 활성화하려면, <a href="./../advanced_config/parameter_reference.html#SDLOG_PROFILE">SDLOG_PROFILE</a>의 비트 7(컴퓨터 비전 및 회피)을 설정합니다.</p><p><img src="`+s+'" alt="ekf2_ev_delay 로그"></p><div class="info custom-block"><p class="custom-block-title">A plot of external data vs. onboard estimate (as above) can be generated using <a href="./../log/flight_log_analysis.html#flightplot">FlightPlot</a> or similar flight analysis tools. At time of writing (July 2021) neither <a href="./../log/flight_log_analysis.html#flight-review-online-tool">Flight Review</a> nor <a href="./../log/flight_log_analysis.html#mavgcl">MAVGCL</a> support this functionality.</p></div><p>이 값은 동적 기동 중에 가장 낮은 EKF 혁신을 산출하는 값을 찾기 위하여, 매개변수를 변경하여 추가 튜닝할 수 있습니다.</p><h2 id="lpe-튜닝과-설정" tabindex="-1">LPE 튜닝과 설정 <a class="header-anchor" href="#lpe-튜닝과-설정" aria-label="Permalink to &quot;LPE 튜닝과 설정&quot;">​</a></h2><p>You will first need to <a href="./../advanced/switching_state_estimators.html">switch to the LPE estimator</a> by setting the following parameters: <a href="./../advanced_config/parameter_reference.html#LPE_EN">LPE_EN</a> (1), <a href="./../advanced_config/parameter_reference.html#EKF2_EN">EKF2_EN</a> (0), <a href="./../advanced_config/parameter_reference.html#ATT_EN">ATT_EN</a> (0).</p><div class="info custom-block"><p class="custom-block-title">If targeting <code>px4_fmu-v2</code> hardware you will also need to use a firmware version that includes the LPE module (firmware for other FMU-series hardware includes both LPE and EKF). LPE 버전은 각 PX4 릴리스의 zip 파일에서 찾거나, 빌드 명령 <code>make px4_fmu-v2_lpe</code>를 사용하여 소스에서 빌드합니다. 자세한 내용은 <a href="./../dev_setup/building_px4.html">코드 빌드</a>을 참고하십시오.</p></div><h3 id="외부-포즈-입력-활성화" tabindex="-1">외부 포즈 입력 활성화 <a class="header-anchor" href="#외부-포즈-입력-활성화" aria-label="Permalink to &quot;외부 포즈 입력 활성화&quot;">​</a></h3><p>LPE에서 외부 위치 정보를 사용하려면 다음 매개변수를 설정하여야 합니다. <em>QGroundControl</em> &gt; <strong>차량 설정 &gt; 매개변수 &gt; 로컬 위치 추정기</strong>에서 설정합니다.</p><table><thead><tr><th>매개변수</th><th>외부 위치 추정 설정</th></tr></thead><tbody><tr><td><a href="./../advanced_config/parameter_reference.html#LPE_FUSION">LPE_FUSION</a></td><td><em>퓨즈 비전 위치</em>가 선택된 경우 비전 통합이 활성화됩니다(기본적으로 활성화되어 있음).</td></tr><tr><td><a href="./../advanced_config/parameter_reference.html#ATT_EXT_HDG_M">ATT_EXT_HDG_M</a></td><td>외부 제목 통합을 활성화하려면 1 또는 2로 설정합니다. 1로 설정하면 비전이 사용되는 반면, 2로 설정하면 MoCap 제목 사용이 활성화됩니다.</td></tr></tbody></table><h3 id="기압계-퓨전-비활성화" tabindex="-1">기압계 퓨전 비활성화 <a class="header-anchor" href="#기압계-퓨전-비활성화" aria-label="Permalink to &quot;기압계 퓨전 비활성화&quot;">​</a></h3><p>VIO 또는 MoCap 정보에서 이미 매우 정확한 고도를 사용할 수 있는 경우에는, LPE에서 기압 보정을 비활성화하여 Z축의 드리프트를 줄이는 것이 유용합니다.</p><p><em>QGroundControl</em>에서 <a href="./../advanced_config/parameter_reference.html#LPE_FUSION">LPE_FUSION</a> 매개변수의 <em>fuse baro</em> 옵션을 선택을 취소하여 수행할 수 있습니다.</p><h3 id="노이즈-매개변수-조정" tabindex="-1">노이즈 매개변수 조정 <a class="header-anchor" href="#노이즈-매개변수-조정" aria-label="Permalink to &quot;노이즈 매개변수 조정&quot;">​</a></h3><p>비전 또는 MoCap 데이터가 매우 정확하고 추정기가 이를 엄격하게 추적하기를 원하는 경우에는, 표준편차 매개변수인 <a href="./../advanced_config/parameter_reference.html#LPE_VIS_XY">LPE_VIS_XY</a> 및 <a href="./../advanced_config/parameter_reference.html#LPE_VIS_Z">LPE_VIS_Z</a>(VIO의 경우) 또는 <a href="./../advanced_config/parameter_reference.html#LPE_VIC_P">LPE_VIC_P</a>(MoCap의 경우)를 감소시켜야 합니다. 표준변차 매개변수를 줄이면, 추정자가 들어오는 포즈 추정치를 더 신뢰하게 됩니다. 허용된 최소값보다 낮게 설정하고, 강제 저장해야 할 수도 있습니다.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>성능이 좋지 않으면, <a href="./../advanced_config/parameter_reference.html#LPE_PN_V">LPE_PN_V</a> 매개변수를 중가시키십시오. 이로 인해 추정자는 속도 추정 중에 측정값을 더 신뢰하게 됩니다.</p></div><h2 id="enabling-auto-modes-with-a-local-position" tabindex="-1">Enabling Auto Modes with a Local Position <a class="header-anchor" href="#enabling-auto-modes-with-a-local-position" aria-label="Permalink to &quot;Enabling Auto Modes with a Local Position&quot;">​</a></h2><p>All PX4 automatic flight modes (such as <a href="./../flight_modes_mc/mission.html">Mission</a>, <a href="./../flight_modes_mc/return.html">Return</a>, <a href="./../flight_modes_mc/land.html">Land</a>, <a href="./../flight_modes_mc/land.html">Hold</a>, <a href="./../flight_modes_mc/orbit.html">Orbit</a>)) require a <em>global</em> position estimate, which would normally come from a GPS/GNSS system.</p><p>Systems that only have a <em>local</em> position estimate (from MOCAP, VIO, or similar) can use the <a href="https://mavlink.io/en/messages/common.html#SET_GPS_GLOBAL_ORIGIN" target="_blank" rel="noreferrer">SET_GPS_GLOBAL_ORIGIN</a> MAVLink message to set the origin of the EKF to a particular global location. EKF will then provide a global position estimate based on origin and local frame position.</p><p>This can then be used when planning and executing indoor missions, or to set a local return point, and so on.</p><h2 id="ros-연동" tabindex="-1">ROS 연동 <a class="header-anchor" href="#ros-연동" aria-label="Permalink to &quot;ROS 연동&quot;">​</a></h2><p>ROS는 외부 포즈 정보를 제공하는 데 <em>필수</em>되지 않지만, 이미 VIO 및 MoCap 시스템과 잘 통합되어 있으므로 적극 권장합니다. PX4는 위와 같이 설정되어 있어야 합니다.</p><h3 id="포즈-데이터를-ros로-가져오기" tabindex="-1">포즈 데이터를 ROS로 가져오기 <a class="header-anchor" href="#포즈-데이터를-ros로-가져오기" aria-label="Permalink to &quot;포즈 데이터를 ROS로 가져오기&quot;">​</a></h3><p>VIO와 MoCap 시스템은 포즈 데이터를 얻는 방법이 다르며, 자체 설정과 주제가 있습니다.</p><p>특정 시스템에 대한 설정은 <a href="#setup_specific_systems">아래</a>에서 설명합니다. 다른 시스템의 경우에는 공급업체의 설정 문서를 참고하십시오.</p><p><a id="relaying_pose_data_to_px4"></a></p><h3 id="포즈-데이터를-px4로-중계" tabindex="-1">포즈 데이터를 PX4로 중계 <a class="header-anchor" href="#포즈-데이터를-px4로-중계" aria-label="Permalink to &quot;포즈 데이터를 PX4로 중계&quot;">​</a></h3><p>MAVROS에는 다음 파이프라인을 사용하여 VIO 또는 MoCap 시스템에서 시각적 추정을 릴레이하는 플러그인이 있습니다.</p><table><thead><tr><th>ROS</th><th>MAVLink</th><th>uORB</th></tr></thead><tbody><tr><td>/mavros/vision_pose/pose</td><td><a href="https://mavlink.io/en/messages/common.html#VISION_POSITION_ESTIMATE" target="_blank" rel="noreferrer">VISION_POSITION_ESTIMATE</a></td><td><code>vehicle_visual_odometry</code></td></tr><tr><td>/mavros/odometry/out (<code>frame_id = odom</code>, <code>child_frame_id = base_link</code>)</td><td><a href="https://mavlink.io/en/messages/common.html#ODOMETRY" target="_blank" rel="noreferrer">ODOMETRY</a> (<code>frame_id =</code> <a href="https://mavlink.io/en/messages/common.html#MAV_FRAME_LOCAL_FRD" target="_blank" rel="noreferrer">MAV_FRAME_LOCAL_FRD</a>)</td><td><code>vehicle_visual_odometry</code></td></tr><tr><td>/mavros/mocap/pose</td><td><a href="https://mavlink.io/en/messages/common.html#ATT_POS_MOCAP" target="_blank" rel="noreferrer">ATT_POS_MOCAP</a></td><td><code>vehicle_mocap_odometry</code></td></tr><tr><td>/mavros/odometry/out (<code>frame_id = odom</code>, <code>child_frame_id = base_link</code>)</td><td><a href="https://mavlink.io/en/messages/common.html#ODOMETRY" target="_blank" rel="noreferrer">ODOMETRY</a> (<code>frame_id =</code> <a href="https://mavlink.io/en/messages/common.html#MAV_FRAME_LOCAL_FRD" target="_blank" rel="noreferrer">MAV_FRAME_LOCAL_FRD</a>)</td><td><code>vehicle_mocap_odometry</code></td></tr></tbody></table><p>위의 파이프라인 중 하나를 LPE와 함께 사용할 수 있습니다.</p><p>EKF2로 작업하는 경우 &quot;비전&quot; 파이프라인만 지원됩니다. EKF2에서 MoCap 데이터를 사용하려면, MoCap에서 가져온 포즈 주제를 <a href="http://wiki.ros.org/roslaunch/XML/remap" target="_blank" rel="noreferrer">다시 매핑</a>하여야 합니다.</p><ul><li><code>geometry_msgs/PoseStamped</code> 또는 <code>geometry_msgs/PoseWithCovarianceStamped</code> 유형의 MoCap ROS 주제는 <code>/mavros/vision_pose/pose</code>로 다시 매핑하여야 합니다. <code>geometry_msgs/PoseStamped</code> 주제는 MoCap에 일반적으로 데이터에 대한 관련 공분산이 없으므로, 가장 일반적입니다.</li><li><code>nav_msgs/Odometry</code> ROS 메시지를 통해 데이터를 가져오면 <code>/mavros/odometry/out</code>에 다시 매핑해야 하며, <code>frame_id&lt; /0&gt; 및 &lt;code&gt;child_frame_id</code>에 따라 차이가 납니다.</li><li>주행 거리 프레임 <code>frame_id = odom</code>, <code>child_frame_id = base_link</code>는 <code>mavros/launch/px4_config.yaml</code>의 파일을 업데이트하여 변경할 수 있습니다. 그러나, 현재 버전의 mavros(<code>1.3.0</code>)는 tf 트리를 사용하여 <code>frame_id</code>에서 하드코딩된 프레임 <code>odom_ned</code>로의 변환을 찾을 수 있어야 합니다. tf 트리에서 하드코딩된 프레임 <code>base_link_frd</code>에 연결하는 <code>child_frame_id</code>에도 동일하게 적용됩니다. mavros <code>1.2.0</code>을 사용 중이고 <code>mavros/launch/px4_config.yaml</code> 파일을 업데이트하지 않은 경우에는, 큰 걱정 없이 주행 거리 측정 프레임 <code>frame_id = odom</code>, <code>child_frame_id = base_link</code>을 안전하게 사용할 수 있습니다.</li><li>Note that if you are sending odometry data to px4 using <code>child_frame_id = base_link</code>, then you need to make sure that the <code>twist</code> portion of the <code>nav_msgs/Odometry</code> message is <strong>expressed in body frame</strong>, <strong>not in inertial frame!!!!!</strong>.</li></ul><h3 id="기준-프레임과-ros" tabindex="-1">기준 프레임과 ROS <a class="header-anchor" href="#기준-프레임과-ros" aria-label="Permalink to &quot;기준 프레임과 ROS&quot;">​</a></h3><p>ROS와 PX4에서 사용하는 로컬과 전역 프레임은 같지 않습니다.</p><table><thead><tr><th>프레임</th><th>PX4</th><th>ROS</th></tr></thead><tbody><tr><td>몸체</td><td>FRD (X <strong>F</strong>orward, Y <strong>R</strong>ight, Z <strong>D</strong>own)</td><td>FLU(X <strong>F</strong>forward, Y <strong>L</strong> ft, Z <strong>U</strong>p), 일반적으로 <code>base_link</code>라는 이름이 지정됨.</td></tr><tr><td>전역</td><td>FRD or NED (X <strong>N</strong>orth, Y <strong>E</strong>ast, Z <strong>D</strong>own)</td><td>FLU 또는 ENU(X <strong>E</strong>ast, Y <strong>N</strong> orth, Z <strong>U</strong>p), 이름은 <code>odm</code> 또는 <code>map</code></td></tr></tbody></table><div class="tip custom-block"><p class="custom-block-title">ROS</p><p>프레임에 대한 자세한 내용은 <a href="http://www.ros.org/reps/rep-0105.html" target="_blank" rel="noreferrer">REP105: 모바일 플랫폼용 좌표 프레임</a>을 참고하십시오.</p></div><p>두 프레임 모두 아래 이미지에 표시됩니다(왼쪽의 FRD/오른쪽의 FLU).</p><p><img src="'+i+`" alt="기준 프레임"></p><p>외부 방향 추정시 EKF2를 사용하면, 자북을 무시하거나 자북에 대한 방향 오프셋을 계산하고 보상할 수 있습니다. 선택에 따라 요 각도는 자북 또는 로컬 <em>x</em>에 대하여 제공됩니다.</p><div class="info custom-block"><p class="custom-block-title">When creating the rigid body in the MoCap software, remember to first align the robot&#39;s local <em>x</em> axis with the world <em>x</em> axis otherwise the yaw estimate will have an offset. 이렇게 하면 외부 포즈 추정 융합이 제대로 작동하지 않을 수 있습니다. 본체와 기준 좌표계가 정렬될 때 요 각도는 0이어야 합니다.</p></div><p>MAVROS를 사용하면 이 작업이 간단합니다. ROS는 ENU 프레임을 관례로 사용하므로, ENU에서 위치 피드백을 제공하여야 합니다. Optitrack 시스템이 있는 경우에는, ENU에 존재하는 ROS 주제에 대한 개체 포즈를 스트리밍하는 <a href="https://github.com/ros-drivers/mocap_optitrack" target="_blank" rel="noreferrer">mocap_optitrack</a> 노드를 사용할 수 있습니다. 다시 매핑하면 변환 없이 그대로 <code>mocap_pose_estimate</code>에 직접 게시할 수 있으며, MAVROS는 NED 변환을 처리합니다.</p><p>MAVROS 주행 거리 측정 플러그인을 사용하면, 좌표 프레임을 쉽게 처리할 수 있습니다. ROS의 tf 패키지를 사용합니다. 외부 포즈 시스템에는 PX4와 일치하지 않는 완전히 다른 프레임 규칙이 있을 수 있습니다. 외부 포즈 추정의 바디 프레임은 MOCAP 소프트웨어에서 바디 프레임을 설정하는 방법이나 드론에 VIO 센서를 장착하는 방법에 따라 달라질 수 있습니다. MAVROS 주행 거리 측정 플러그인은 MAVROS에 의해 알려진 기체의 FRD 또는 FLU 본체 프레임과 관련하여 외부 포즈의 자식 프레임이 어떻게 향하고 있는 지 알아야 합니다. 따라서 외부 포즈의 바디 프레임을 tf 트리에 추가하여야 합니다. 이것은 ROS 시작 파일에 다음 줄의 수정된 버전을 포함하여 수행할 수 있습니다.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>  &lt;node pkg=&quot;tf&quot; type=&quot;static_transform_publisher&quot; name=&quot;tf_baseLink_externalPoseChildFrame&quot;</span></span>
<span class="line"><span>        args=&quot;0 0 0 &lt;yaw&gt; &lt;pitch&gt; &lt;roll&gt; base_link &lt;external_pose_child_frame&gt; 1000&quot;/&gt;</span></span></code></pre></div><p>외부 포즈의 바디 프레임이 <code>base_link</code> 또는 <code>base_link_frd</code>에 정상적으로 연결되도록 yaw, pitch 및 roll 값을 변경하였는 지 확인하십시오. 프레임 간의 변환을 지정하는 방법에 대한 추가 도움말은 <a href="http://wiki.ros.org/tf#static_transform_publisher" target="_blank" rel="noreferrer">tf 패키지</a>를 참고하십시오. rviz를 사용하여 프레임을 올바르게 부착했는 지 확인할 수 있습니다. <code>external_pose_child_frame</code>의 이름은 <code>nav_msgs/Odometry</code> 메시지의 child_frame_id와 일치하여야 합니다. 외부 포즈의 기준 프레임에도 동일하게 적용됩니다. 외부 포즈의 기준 좌표계를 <code>odom</code> 또는 <code>odom_frd</code> 프레임에 자식으로 부착하여야 합니다. 따라서, 다음 코드 줄을 적절하게 조정하십시오.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>  &lt;node pkg=&quot;tf&quot; type=&quot;static_transform_publisher&quot; name=&quot;tf_odom_externalPoseParentFrame&quot;</span></span>
<span class="line"><span>        args=&quot;0 0 0 &lt;yaw&gt; &lt;pitch&gt; &lt;roll&gt; odom &lt;external_pose_parent_frame&gt; 1000&quot;/&gt;</span></span></code></pre></div><p>기준 프레임에 위쪽을 가리키는 z축이 있으면, 회전 없이(yaw=0, pitch=0, roll=0) <code>odom</code> 프레임에 연결할 수 있습니다. <code>external_pose_parent_frame</code>의 이름은 주행 거리 메시지의 frame_id와 일치하여야 합니다.</p><div class="info custom-block"><p class="custom-block-title">When using the MAVROS <em>odom</em> plugin, it is important that no other node is publishing a transform between the external pose&#39;s reference and child frame. 이것은 <em>tf</em> 트리를 깨뜨릴 수 있습니다.</p></div><p><a id="setup_specific_systems"></a></p><h2 id="특정-시스템-설정" tabindex="-1">특정 시스템 설정 <a class="header-anchor" href="#특정-시스템-설정" aria-label="Permalink to &quot;특정 시스템 설정&quot;">​</a></h2><h3 id="optitrack-mocap" tabindex="-1">OptiTrack MoCap <a class="header-anchor" href="#optitrack-mocap" aria-label="Permalink to &quot;OptiTrack MoCap&quot;">​</a></h3><p>다음 단계는 <a href="https://optitrack.com/motion-capture-robotics/" target="_blank" rel="noreferrer">OptiTrack</a> 시스템에서 PX4로 위치 추정치를 제공하는 방법을 설명합니다. MoCap 시스템이 보정된 것으로 가정합니다. 보정 가이드는 <a href="https://www.youtube.com/watch?v=cNZaFEghTBU" target="_blank" rel="noreferrer">이 동영상</a>을 참고하십시오.</p><h4 id="motive-mocap-소프트웨어의-단계" tabindex="-1"><em>Motive</em> MoCap 소프트웨어의 단계 <a class="header-anchor" href="#motive-mocap-소프트웨어의-단계" aria-label="Permalink to &quot;*Motive* MoCap 소프트웨어의 단계&quot;">​</a></h4><ul><li>로봇의 앞으로 방향을 <a href="https://v20.wiki.optitrack.com/index.php?title=Template:Coordinate_System" target="_blank" rel="noreferrer">시스템 +x축</a>에 맞춥니다.</li><li><a href="https://www.youtube.com/watch?v=1e6Qqxqe-k0" target="_blank" rel="noreferrer">Motive 소프트웨어에서 강체를 정의합니다</a>. 로봇에 공백이 포함되지 않은 이름을 지정합니다. 예: <code>Rigidbody 1</code> 대신 <code>robot1</code></li><li><a href="https://www.youtube.com/watch?v=yYRNG58zPFo" target="_blank" rel="noreferrer">Frame Broadacst 및 VRPN 스트리밍 활성화</a></li><li>위쪽 축을 Z축으로 설정합니다(기본값은 Y).</li></ul><h4 id="포즈-데이터를-ros로-가져오기-1" tabindex="-1">포즈 데이터를 ROS로 가져오기 <a class="header-anchor" href="#포즈-데이터를-ros로-가져오기-1" aria-label="Permalink to &quot;포즈 데이터를 ROS로 가져오기&quot;">​</a></h4><ul><li><code>vrpn_client_ros</code> 패키지를 설치합니다.</li><li>다음 명령어로 개별 주제에 대한 각 강체의 포즈를 얻을 수 있습니다.<div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">roslaunch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> vrpn_client_ros</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sample.launch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> server:=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">mocap</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> machine</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div></li></ul><p>rigidbody의 이름을 <code>robot1</code>으로 지정하면, <code>/vrpn_client_node/robot1/pose</code>와 같은 주제를 얻게 됩니다.</p><h4 id="포즈-데이터-중계-재매핑" tabindex="-1">포즈 데이터 중계/재매핑 <a class="header-anchor" href="#포즈-데이터-중계-재매핑" aria-label="Permalink to &quot;포즈 데이터 중계/재매핑&quot;">​</a></h4><p>MAVROS는 <code>/mavros/vision_pose/pose</code>에 게시된 포즈 데이터를 PX4로 릴레이하는 플러그인을 제공합니다. MAVROS가 실행 중이라고 가정하면, MoCap <code>/vrpn_client_node/&lt;rigid_body_name&gt;/pose</code>에서 가져온 포즈 주제를 <code>/mavros/vision_pose/pose</code>로 직접 <strong>다시 매핑</strong>하면 됩니다. MAVROS가 <code>ATT_POS_MOCAP</code>를 PX4에 제공하는 <code>mocap</code> 주제도 있지만, EKF2에는 적용되지 않습니다. 그러나 LPE에는 적용됩니다.</p><div class="info custom-block"><p class="custom-block-title">Remapping pose topics is covered above <a href="#relaying_pose_data_to_px4">Relaying pose data to PX4</a> (<code>/vrpn_client_node/&lt;rigid_body_name&gt;/pose</code> is of type <code>geometry_msgs/PoseStamped</code>).</p></div><p>위에서 설명한 대로 EKF2 매개변수를 설정하였으면, 이제 PX4가 설정되고 MoCap 데이터를 통합합니다.</p><p>이제 첫 번째 비행을 진행할 준비가 되었습니다.</p><h2 id="첫-번째-비행" tabindex="-1">첫 번째 비행 <a class="header-anchor" href="#첫-번째-비행" aria-label="Permalink to &quot;첫 번째 비행&quot;">​</a></h2><p>위에서 설명한 (특정) 시스템 중 하나를 설정하였으면, 이제 테스트할 준비가 되었습니다. 아래 지침은 MoCap 및 VIO 시스템에서 수행하는 방법을 설명합니다.</p><h3 id="외부-추정-확인" tabindex="-1">외부 추정 확인 <a class="header-anchor" href="#외부-추정-확인" aria-label="Permalink to &quot;외부 추정 확인&quot;">​</a></h3><p>첫 비행 전에 다음을 확인하십시오.</p><ul><li>PX4 매개변수 <code>MAV_ODOM_LP</code>를 1로 설정합니다. PX4는 수신된 외부 포즈를 MAVLink <a href="https://mavlink.io/en/messages/common.html#ODOMETRY" target="_blank" rel="noreferrer">ODOMETRY</a> 메시지로 다시 스트리밍합니다.</li><li>You can check these MAVLink messages with the <em>QGroundControl</em> <a href="https://docs.qgroundcontrol.com/master/en/qgc-user-guide/analyze_view/mavlink_inspector.html" target="_blank" rel="noreferrer">MAVLink Inspector</a> In order to do this, yaw the vehicle until the quaternion of the <code>ODOMETRY</code> message is very close to a unit quaternion. (w=1, x=y=z=0)</li><li>이 시점에서 몸체 프레임은 외부 포즈 시스템의 기준 프레임과 정렬됩니다. 차량을 구르거나 피칭하지 않고 단위 쿼터니언에 가까운 쿼터니언을 얻을 수 없다면, 프레임에 여전히 피치 또는 롤 오프셋이 있을 수 있습니다. 이 경우에는 더 이상 진행하지 말고, 좌표 프레임을 다시 확인하십시오.</li><li>정렬되면 지면에서 차량을 들어올릴 수 있으며, 위치의 z 좌표가 감소하는 것을 볼 수 있습니다. 차량을 앞쪽으로 움직이면, 위치의 x 좌표가 증가합니다. 차량을 오른 쪽으로 이동하면, y 좌표는 증가합니다. 외부 포즈 시스템에서 선형 속도도 전송하는 경우에는, 선형 속도를 확인하여야 합니다. 선형 속도가 <em>FRD</em> 몸체 프레임 참조 프레임으로 표현되는 지 확인합니다.</li><li>PX4 매개변수 <code>MAV_ODOM_LP</code>를 0로 재설정합니다. PX4는 이 메시지의 스트리밍을 중지합니다.</li></ul><p>이러한 단계가 유지되면, 첫 번째 비행을 시도할 수 있습니다.</p><p>로봇을 바닥에 놓고, MoCap 피드백 스트리밍을 시작합니다. 왼쪽(스로틀) 스틱을 내리고, 모터를 작동시킵니다.</p><p>이때 왼쪽 스틱을 가장 낮은 위치에 놓고, 위치 제어로 전환합니다. 초록불이 켜져야 합니다. 녹색 표시등은 위치 피드백을 사용할 수 있고, 위치 제어가 활성화되었음을 알려줍니다.</p><p>왼쪽 스틱을 가운데에 놓으면, 데드존입니다. 이 스틱 값으로 로봇은 고도를 유지합니다. 스틱을 올리면 기준 고도가 증가하고, 값을 낮추면 감소합니다. x와 y의 오른쪽 스틱에 대해서도 동일합니다.</p><p>왼쪽 스틱의 값을 높이면 로봇이 이륙합니다. 바로 중간에 다시 놓습니다. 위치를 유지할 수 있는 지 확인하십시오.</p><p>작동하는 경우에는, 원격 지상국에서 위치 설정값을 전송하여 <a href="./offboard_control.html">오프보드</a> 실험을 설정할 수 있습니다.</p>`,86);function T(M,x,y,A,S,F){return r(),o("div",null,[d,e("p",null,[t("예를 들어, Optitrack 프레임워크를 사용하는 경우 로컬 프레임은 수평면(앞면 "),c,t(", 오른쪽 "),h,t(")에 "),e("mjx-container",m,[(r(),o("svg",p,g)),f]),t(" 및 "),e("mjx-container",u,[(r(),o("svg",k,E)),v]),t("가 있는 반면 "),O,t(" 축은 수직이고 위쪽을 가르킵니다. 간단한 트릭은 NED 규칙을 얻기 위해 축을 변경하는 것입니다.")]),P])}const C=n(l,[["render",T]]);export{w as __pageData,C as default};
