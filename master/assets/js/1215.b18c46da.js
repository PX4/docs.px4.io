(window.webpackJsonp=window.webpackJsonp||[]).push([[1215],{2251:function(t,_,a){"use strict";a.r(_);var e=a(19),s=Object(e.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"ulog-파일-형식"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ulog-파일-형식"}},[t._v("#")]),t._v(" ULog 파일 형식")]),t._v(" "),a("p",[t._v("ULog는 시스템 데이터 로깅의 파일 형식입니다.")]),t._v(" "),a("p",[t._v("형식은 자체 설명적입니다. 즉, 기록되는 형식과 메시지 유형이 포함됩니다. "),a("RouterLink",{attrs:{to:"/ko/dev_log/logging.html"}},[t._v("시스템 로거")]),t._v("를 사용하여 기록된 주제의 "),a("em",[t._v("기본 설정")]),t._v("을 SD 카드에서 변경할 수 있습니다..")],1),t._v(" "),a("p",[t._v("장치 입력(센서 등), 내부 상태(cpu 부하, 태도 등) 및 "),a("code",[t._v("printf")]),t._v(" 로그 메시지를 로깅할 수 있습니다.")]),t._v(" "),a("p",[t._v("형식은 모든 바이너리 유형에 대해 Little Endian을 사용합니다.")]),t._v(" "),a("h2",{attrs:{id:"데이터-형식"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#데이터-형식"}},[t._v("#")]),t._v(" 데이터 형식")]),t._v(" "),a("p",[t._v("다음 바이너리 형식을 사용합니다. C의 자료형에 해당합니다:")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("형식")]),t._v(" "),a("th",[t._v("바이트 크기")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("int8_t, uint8_t")]),t._v(" "),a("td",[t._v("1")])]),t._v(" "),a("tr",[a("td",[t._v("int16_t, uint16_t")]),t._v(" "),a("td",[t._v("2")])]),t._v(" "),a("tr",[a("td",[t._v("int32_t, uint32_t")]),t._v(" "),a("td",[t._v("4")])]),t._v(" "),a("tr",[a("td",[t._v("int64_t, uint64_t")]),t._v(" "),a("td",[t._v("8")])]),t._v(" "),a("tr",[a("td",[t._v("float")]),t._v(" "),a("td",[t._v("4")])]),t._v(" "),a("tr",[a("td",[t._v("double")]),t._v(" "),a("td",[t._v("8")])]),t._v(" "),a("tr",[a("td",[t._v("bool, char")]),t._v(" "),a("td",[t._v("1")])])])]),t._v(" "),a("p",[t._v("또한 다음과 같이 배열에도 활용할 수 있습니다. "),a("code",[t._v("float[5]")]),t._v(". 일반적으로 모든 문자열("),a("code",[t._v("char[length]")]),t._v(")은 끝에 "),a("code",[t._v("'\\0'")]),t._v("을 포함하지 않습니다. 문자열 비교는 대소문자를 구분합니다.")]),t._v(" "),a("h2",{attrs:{id:"파일-구조"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#파일-구조"}},[t._v("#")]),t._v(" 파일 구조")]),t._v(" "),a("p",[t._v("파일은 세 섹션으로 구성됩니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("----------------------\n|       Header       |\n----------------------\n|    Definitions     |\n----------------------\n|        Data        |\n----------------------\n")])])]),a("h3",{attrs:{id:"헤더-섹션"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#헤더-섹션"}},[t._v("#")]),t._v(" 헤더 섹션")]),t._v(" "),a("p",[t._v("헤더는 고정 크기 섹션이며, 다음 형식(16바이트)을 갖습니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("----------------------------------------------------------------------\n| 0x55 0x4c 0x6f 0x67 0x01 0x12 0x35 | 0x01         | uint64_t       |\n| File magic (7B)                    | Version (1B) | Timestamp (8B) |\n----------------------------------------------------------------------\n")])])]),a("p",[t._v("버전은 파일 형식 버전이며, 현재 값은 1입니다. 타임스탬프는 "),a("code",[t._v("uint64_t")]),t._v(" 정수형이며, 로깅을 시작한 시각을 마이크로초 단위로 표기합니다.")]),t._v(" "),a("h3",{attrs:{id:"정의-섹션"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#정의-섹션"}},[t._v("#")]),t._v(" 정의 섹션")]),t._v(" "),a("p",[t._v("가변 길이 섹션에는 버전 정보, 형식 정의 및 (초기) 매개변수 값이 포함됩니다.")]),t._v(" "),a("p",[t._v("데이터 섹션 정의는 메시지 스트림으로 구성됩니다. 각 데이터 섹션은 다음의 헤더로 시작합니다:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("message_header_s")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("uint16_t")]),t._v(" msg_size"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("uint8_t")]),t._v(" msg_type\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[a("code",[t._v("msg_size")]),t._v("는 헤더가 없는 바이트 단위의 메시지 크기입니다("),a("code",[t._v("hdr_size")]),t._v("= 3바이트). "),a("code",[t._v("msg_type")]),t._v("은 콘텐츠를 정의하며 다음 중 하나입니다.")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("'B': 비트 집합 메시지에 플래그를 지정합니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("struct ulog_message_flag_bits_s {\n  struct message_header_s;\n  uint8_t compat_flags[8];\n  uint8_t incompat_flags[8];\n  uint64_t appended_offsets[3]; ///< file offset(s) for appended data if appending bit is set\n};\n")])])]),a("p",[t._v("이 메시지는 처음 메시지 "),a("strong",[t._v("이어야 합니다")]),t._v(". 그 다음에는 고정 상수 오프셋 값이 들어간 헤더 섹션이 옵니다.")]),t._v(" "),a("ul",[a("li",[a("p",[a("code",[t._v("compat_flags")]),t._v(": 호환 플래그 비트값")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("compat_flags[0]")]),t._v(", 비트 0, "),a("em",[t._v("DEFAULT_PARAMETERS")]),t._v(": 설정되면 로그에 매개변수 기본값(메시지 'Q')이 포함됩니다.")])]),t._v(" "),a("p",[t._v("나머지 비트는 현재 정의되지 않았으며 ,모두 0으로 설정하여야 합니다. 이 비트는 향후 기존 파서와 호환되는 ULog 변경에 사용할 수 있습니다. 이는 알 수 없는 비트 중 하나가 설정되어 있으면, 파서가 해당 비트를 무시할 수 있음을 의미합니다.")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("incompat_flags")]),t._v(": 비호환성 플래그 비트값. 로그에 추가 데이터가 포함되어 있고, "),a("code",[t._v("appended_offsets")]),t._v(" 중 하나 이상이 0이 아닌 경우 인덱스 0의 LSB 비트가 1로 설정됩니다. 다른 모든 비트는 정의되지 않으며, 0으로 설정하여야 합니다. 파서는 이러한 비트 세트 중 하나를 찾으면, 로그 파싱을 거부합니다. 이것은 기존 파서가 처리할 수 없는 주요 변경 사항을 도입하는 데 사용할 수 있습니다.")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("appended_offsets")]),t._v(": 추가된 데이터에 대한 파일 오프셋(0부터 시작). 데이터가 추가되지 않은 경우에는 모든 오프셋은 0이어야 합니다. 이것은 메시지 중간에 멈출 수 있는 로그에 대한 데이터를 안정적으로 추가할 수 있습니다.")]),t._v(" "),a("p",[t._v("데이터를 추가하는 프로세스는 다음과 같습니다.")]),t._v(" "),a("ul",[a("li",[t._v("관련 "),a("code",[t._v("incompat_flags")]),t._v(" 비트 값을 설정합니다.")]),t._v(" "),a("li",[a("code",[t._v("append_offsets")]),t._v(" 처음 값을 로그 파일 길이 값인 0으로 설정합니다.")]),t._v(" "),a("li",[t._v("그런 다음 데이터 섹션에 유효한 모든 유형의 메시지를 추가합니다.")])])])]),t._v(" "),a("p",[t._v("향후 ULog 사양에서 이 메시지 끝에 추가 필드가 존재할 수 있습니다. 이것은 파서가 이 메시지의 고정된 길이를 가정해서는 안 된다는 것을 의미합니다. 메시지가 예상보다 길면(현재 40바이트) 초과 바이트는 무시합니다.")])]),t._v(" "),a("li",[a("p",[t._v("'F': 다른 정의에서 중첩 유형으로 기록되거나 사용될 수 있는 단일(복합) 유형에 대한 형식 정의입니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("struct message_format_s {\n  struct message_header_s header;\n  char format[header.msg_size];\n};\n")])])]),a("p",[a("code",[t._v("format")]),t._v(": 다음 형식의 일반 텍스트 문자열: "),a("code",[t._v("message_name:field0;field1;")]),t._v(" "),a("code",[t._v(";")]),t._v("으로 구분된 임의의 양의 필드(최소 1개)가 있을 수 있습니다. 필드 형식은 배열의 경우 "),a("code",[t._v("type field_name")]),t._v(" 또는 "),a("code",[t._v("type[array_length] field_name")]),t._v("입니다(고정 크기 배열만 지원됨). "),a("code",[t._v("type")]),t._v("은 기본 바이너리 유형 중 하나이거나 다른 형식 정의(중첩 사용)의 "),a("code",[t._v("message_name")]),t._v("입니다. 유형은 정의되기 전에 사용할 수 있습니다. 임의의 중첩이 있을 수 있지만, 순환 종속성은 없습니다.")]),t._v(" "),a("p",[t._v("일부 필드 이름은 특별합니다.")]),t._v(" "),a("ul",[a("li",[a("p",[a("code",[t._v("timestamp")]),t._v(": 기록된 모든 메시지("),a("code",[t._v("message_add_logged_s")]),t._v(")에는 타임스탬프 필드가 포함되어야 합니다(첫 번째 필드일 필요는 없음). 유형은 "),a("code",[t._v("uint64_t")]),t._v("(현재 유일하게 사용됨), "),a("code",[t._v("uint32_t")]),t._v(", "),a("code",[t._v("uint16_t")]),t._v(" 또는 "),a("code",[t._v("uint8_t")]),t._v("일 수 있습니다. 단위는 항상 마이크로초이며 "),a("code",[t._v("uint8_t")]),t._v(" 단위는 밀리초입니다. 로그 작성기는 랩어라운드를 감지할 수 있을 만큼 충분히 자주 메시지를 기록해야 하고, 로그 판독기는 랩어라운드를 처리하여야 합니다(그리고 드롭아웃을 고려해야 함). 타임스탬프는 "),a("code",[t._v("msg_id")]),t._v("가 동일한 메시지 시리즈에 대해 항상 단조 증가해야 합니다.")])]),t._v(" "),a("li",[a("p",[t._v("패딩: "),a("code",[t._v("_padding")]),t._v("으로 시작하는 필드 이름은 표시되지 않아야 하며, 해당 데이터는 독자가 무시하여야 합니다. 이 필드는 올바른 정렬을 보장하기 위하여 작성자가 삽입할 수 있습니다.")]),t._v(" "),a("p",[t._v("패딩 필드가 마지막 필드인 경우 불필요한 데이터 쓰기를 방지하기 위하여, 이 필드는 기록되지 않습니다. 즉, "),a("code",[t._v("message_data_s.data")]),t._v("가 패딩 크기만큼 짧아집니다. 그러나 메시지가 중첩 정의에서 사용될 때 패딩은 여전히 필요합니다.")])])])]),t._v(" "),a("li",[a("p",[t._v("'I': 정보 메세지")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("message_info_s")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("message_header_s")]),t._v(" header"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("uint8_t")]),t._v(" key_len"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("key_len"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("header"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("msg_size"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("key_len"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[a("code",[t._v("key")]),t._v("는 형식 메시지에서와 같이 일반 문자열(사용자 정의 유형일 수도 있음)이지만, "),a("code",[t._v(";")]),t._v("으로 끝나지 않는 단일 필드로 구성됩니다. "),a("code",[t._v("float[3] myvalues")]),t._v(". "),a("code",[t._v("value")]),t._v("에는 "),a("code",[t._v("key")]),t._v("에 의해 설명된 데이터가 포함됩니다.")]),t._v(" "),a("p",[t._v("특정 키가 포함된 정보 메시지는 전체 로그에서 최대 한 번만 발생하여야 합니다. 파서는 정보 메시지를 사전으로 저장할 수 있습니다.")]),t._v(" "),a("p",[t._v("사전 정의된 정보 메시지는 다음과 같습니다.")])])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("키")]),t._v(" "),a("th",[t._v("설명")]),t._v(" "),a("th",[t._v("예제 값")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("char[value_len] sys_name")]),t._v(" "),a("td",[t._v("시스템 이름")]),t._v(" "),a("td",[t._v('"PX4"')])]),t._v(" "),a("tr",[a("td",[t._v("char[value_len] ver_hw")]),t._v(" "),a("td",[t._v("하드웨어 버전 (보드)")]),t._v(" "),a("td",[t._v('"PX4FMU_V4"')])]),t._v(" "),a("tr",[a("td",[t._v("char[value_len] ver_hw_subtype")]),t._v(" "),a("td",[t._v("보드 하위 버전(변형판)")]),t._v(" "),a("td",[t._v('"V2"')])]),t._v(" "),a("tr",[a("td",[t._v("char[value_len] ver_sw")]),t._v(" "),a("td",[t._v("소프트웨어 버전(git tag)")]),t._v(" "),a("td",[t._v('"7f65e01"')])]),t._v(" "),a("tr",[a("td",[t._v("char[value_len] ver_sw_branch")]),t._v(" "),a("td",[t._v("git branch")]),t._v(" "),a("td",[t._v('"master"')])]),t._v(" "),a("tr",[a("td",[t._v("uint32_t ver_sw_release")]),t._v(" "),a("td",[t._v("소프트웨어 버전 (아래 참고)")]),t._v(" "),a("td",[t._v("0x010401ff")])]),t._v(" "),a("tr",[a("td",[t._v("char[value_len] sys_os_name")]),t._v(" "),a("td",[t._v("운영체제 이름")]),t._v(" "),a("td",[t._v('"Linux"')])]),t._v(" "),a("tr",[a("td",[t._v("char[value_len] sys_os_ver")]),t._v(" "),a("td",[t._v("운영체제 버전 (git tag)")]),t._v(" "),a("td",[t._v('"9f82919"')])]),t._v(" "),a("tr",[a("td",[t._v("uint32_t ver_os_release")]),t._v(" "),a("td",[t._v("운영체제 버전 (아래 참고)")]),t._v(" "),a("td",[t._v("0x010401ff")])]),t._v(" "),a("tr",[a("td",[t._v("char[value_len] sys_toolchain")]),t._v(" "),a("td",[t._v("툴체인 이름")]),t._v(" "),a("td",[t._v('"GNU GCC"')])]),t._v(" "),a("tr",[a("td",[t._v("char[value_len] sys_toolchain_ver")]),t._v(" "),a("td",[t._v("툴체인 버전")]),t._v(" "),a("td",[t._v('"6.2.1"')])]),t._v(" "),a("tr",[a("td",[t._v("char[value_len] sys_mcu")]),t._v(" "),a("td",[t._v("칩 이름과 버전")]),t._v(" "),a("td",[t._v('"STM32F42x, rev A"')])]),t._v(" "),a("tr",[a("td",[t._v("char[value_len] sys_uuid")]),t._v(" "),a("td",[t._v("차량 고유 식별자(예: MCU ID)")]),t._v(" "),a("td",[t._v('"392a93e32fa3"...')])]),t._v(" "),a("tr",[a("td",[t._v("char[value_len] log_type")]),t._v(" "),a("td",[t._v("로그 형식(지정하지 않으면 전체 기록)")]),t._v(" "),a("td",[t._v('"mission"')])]),t._v(" "),a("tr",[a("td",[t._v("char[value_len] replay")]),t._v(" "),a("td",[t._v("재생 모드인 경우 재생된 로그의 파일 이름")]),t._v(" "),a("td",[t._v('"log001.ulg"')])]),t._v(" "),a("tr",[a("td",[t._v("int32_t time_ref_utc")]),t._v(" "),a("td",[t._v("UTC 시간 오프셋(초)")]),t._v(" "),a("td",[t._v("-3600")])])])]),t._v(" "),a("p",[a("code",[t._v("ver_sw_release")]),t._v(" 및 "),a("code",[t._v("ver_os_release")]),t._v(" 형식은 0xAABBCCTT입니다. 여기서 AA는 메이저, BB는 마이너, CC는 패치, TT는 유형입니다. 유형은 다음과 같이 정의됩니다. "),a("code",[t._v(">= 0")]),t._v(": 개발, "),a("code",[t._v(">= 64")]),t._v(": 알파 버전, "),a("code",[t._v(">= 128")]),t._v(": 베타 버전, "),a("code",[t._v(">= 192")]),t._v(": RC 버전, "),a("code",[t._v("== 255")]),t._v(": 릴리스 버전. 예를 들어 0x010402ff는 릴리스 버전 v1.4.2로 변환됩니다.")]),t._v(" "),a("p",[t._v("이 메시지는 데이터 섹션에서도 사용할 수 있습니다(그러나 선호하는 섹션임).")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("'M': 다중 정보 메세지")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ulog_message_info_multiple_header_s")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("message_header_s")]),t._v(" header"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("uint8_t")]),t._v(" is_continued"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("///< can be used for arrays")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("uint8_t")]),t._v(" key_len"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("key_len"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("header"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("msg_size"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("key_len"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("동일한 키를 가진 여러 메시지가 있을 수 있다는 점을 제외하고는 정보 메시지와 동일합니다(파서는 목록으로 저장함). "),a("code",[t._v("is_continued")]),t._v("는 분할 메시지에 사용할 수 있습니다. 1로 설정하면 동일한 키를 가진 이전 메시지의 일부입니다. 파서는 다중 메시지를 로그에서 발생하는 메시지와 동일한 순서를 사용하여 2D 목록으로 저장할 수 있습니다.")])]),t._v(" "),a("li",[a("p",[t._v("'P': 매개변수 메세지 "),a("code",[t._v("message_info_s")]),t._v("와 동일한 형식입니다. 매개변수가 런타임 중에 동적으로 변경되는 경우에는 이 메시지는 데이터 섹션에서도 사용할 수 있습니다. 데이터 유형은 "),a("code",[t._v("int32_t")]),t._v(", "),a("code",[t._v("float")]),t._v("으로 제한됩니다.")])]),t._v(" "),a("li",[a("p",[t._v("'Q': 매개변수 기본 메시지")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ulog_message_parameter_default_header_s")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("message_header_s")]),t._v(" header"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("uint8_t")]),t._v(" default_types"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("uint8_t")]),t._v(" key_len"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("key_len"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("header"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("msg_size"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("key_len"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[a("code",[t._v("default_types")]),t._v("는 비트 필드이며 값이 속한 그룹을 정의합니다. 최소한 하나의 비트가 설정되어야 합니다.")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("1<<0")]),t._v(":: 시스템 전체 기본값")]),t._v(" "),a("li",[a("code",[t._v("1<<1")]),t._v(": 현재 설정(예: 기체)의 기본값")])]),t._v(" "),a("p",[t._v("로그에는 모든 매개변수에 대한 기본값이 포함되어 있지 않을 수 있습니다. 이러한 경우 기본값은 매개변수 값과 같고, 다른 기본 유형은 독립적으로 처리됩니다. 이 메시지는 데이터 섹션에서도 사용할 수 있습니다. 데이터 유형은 "),a("code",[t._v("int32_t")]),t._v(", "),a("code",[t._v("float")]),t._v("으로 제한됩니다.")])])]),t._v(" "),a("p",[t._v("이 섹션은 첫 번째 "),a("code",[t._v("message_add_logged_s")]),t._v(" 또는 "),a("code",[t._v("message_logging_s")]),t._v(" 메시지가 시작되기 전에 끝납니다.")]),t._v(" "),a("h3",{attrs:{id:"데이터-섹션"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#데이터-섹션"}},[t._v("#")]),t._v(" 데이터 섹션")]),t._v(" "),a("p",[t._v("다음 메시지는 이 섹션에 속합니다.")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("'A': 이름으로 메시지를 구독하고 "),a("code",[t._v("message_data_s")]),t._v("에서 사용되는 ID를 지정합니다. 이것은 첫 번째 해당 "),a("code",[t._v("message_data_s")]),t._v("보다 이전에 위치하여야 합니다.")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("message_add_logged_s")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("message_header_s")]),t._v(" header"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("uint8_t")]),t._v(" multi_id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("uint16_t")]),t._v(" msg_id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" message_name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("header"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("msg_size"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[a("code",[t._v("multi_id")]),t._v(": 동일한 메시지 형식에 여러 인스턴스가 있을 수 있습니다(예: 시스템에 동일한 유형의 센서가 두 개 있는 경우). 기본 및 첫 번째 인스턴스는 0이어야 합니다. "),a("code",[t._v("msg_id")]),t._v(": "),a("code",[t._v("message_data_s")]),t._v(" 데이터와 일치하는 고유 ID입니다. 처음 사용할 때는 이것을 0으로 설정한 다음 증가시켜야 합니다. 구독 취소 후에도 동일한 "),a("code",[t._v("msg_id")]),t._v("를 다른 구독에 두 번 사용해서는 안 됩니다. "),a("code",[t._v("message_name")]),t._v(": 구독할 메시지 이름입니다. "),a("code",[t._v("message_format_s")]),t._v(" 정의 중 하나와 일치하여야 합니다.")])]),t._v(" "),a("li",[a("p",[t._v("'R': 메시지를 구독 취소하여 더 이상 기록되지 않음을 표시합니다(현재 사용되지 않음).")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("message_remove_logged_s")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("message_header_s")]),t._v(" header"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("uint16_t")]),t._v(" msg_id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])]),t._v(" "),a("li",[a("p",[t._v("'D': 기록된 데이터를 포함합니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("struct message_data_s {\n  struct message_header_s header;\n  uint16_t msg_id;\n  uint8_t data[header.msg_size-2];\n};\n")])])]),a("p",[a("code",[t._v("msg_id")]),t._v(": "),a("code",[t._v("message_add_logged_s")]),t._v(" 메시지로 정의됩니다. "),a("code",[t._v("data")]),t._v("에는 "),a("code",[t._v("message_format_s")]),t._v("에 정의된 대로 기록된 바이너리 메시지가 포함됩니다. 패딩 필드의 특수 처리에 대해서는 위를 참고하십시오.")])]),t._v(" "),a("li",[a("p",[t._v("'L': 로깅 문자열 메시지, 즉 printf 출력.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("struct message_logging_s {\n  struct message_header_s header;\n  uint8_t log_level;\n  uint64_t timestamp;\n  char message[header.msg_size-9]\n};\n")])])]),a("p",[a("code",[t._v("timestamp")]),t._v(": 마이크로초 단위, "),a("code",[t._v("log_level")]),t._v(": Linux 커널에서와 동일:")])])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("이름")]),t._v(" "),a("th",[t._v("레벨")]),t._v(" "),a("th",[t._v("설명")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("EMERG")]),t._v(" "),a("td",[t._v("'0'")]),t._v(" "),a("td",[t._v("시스템 사용 불가")])]),t._v(" "),a("tr",[a("td",[t._v("ALERT")]),t._v(" "),a("td",[t._v("'1'")]),t._v(" "),a("td",[t._v("즉시 조치")])]),t._v(" "),a("tr",[a("td",[t._v("CRIT")]),t._v(" "),a("td",[t._v("'2'")]),t._v(" "),a("td",[t._v("임계 조건")])]),t._v(" "),a("tr",[a("td",[t._v("ERR")]),t._v(" "),a("td",[t._v("'3'")]),t._v(" "),a("td",[t._v("오류 조건")])]),t._v(" "),a("tr",[a("td",[t._v("WARNING")]),t._v(" "),a("td",[t._v("'4'")]),t._v(" "),a("td",[t._v("경고 조건")])]),t._v(" "),a("tr",[a("td",[t._v("NOTICE")]),t._v(" "),a("td",[t._v("'5'")]),t._v(" "),a("td",[t._v("정상적이지만 중요한 상태")])]),t._v(" "),a("tr",[a("td",[t._v("INFO")]),t._v(" "),a("td",[t._v("'6'")]),t._v(" "),a("td",[t._v("정보 제공")])]),t._v(" "),a("tr",[a("td",[t._v("DEBUG")]),t._v(" "),a("td",[t._v("'7'")]),t._v(" "),a("td",[t._v("디버그 수준 메시지")])])])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("'C': 태그가 지정된 로깅된 문자열 메시지")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("struct message_logging_tagged_s {\n  struct message_header_s header;\n  uint8_t log_level;\n  uint16_t tag;\n  uint64_t timestamp;\n  char message[header.msg_size-9]\n};\n")])])]),a("p",[a("code",[t._v("tag")]),t._v(": 기록된 메시지 문자열의 소스를 나타내는 ID입니다. 시스템 아키텍처에 따라 프로세스, 스레드 또는 클래스를 나타낼 수 있습니다. 예를 들어, 다양한 페이로드, 외부 디스크, 직렬 장치 등을 제어하기 위해 여러 프로세스를 실행하는 온보드 컴퓨터에 대한 참조 구현은 "),a("code",[t._v("uint16_t 열거형")]),t._v("을 사용하여 이러한 프로세스 식별자를 "),a("code",[t._v("message_logging_tagged_s")]),t._v("의 태그 속성으로 인코딩할 수 있습니다. 구조체는 다음과 같습니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("enum class ulog_tag : uint16_t {\n  unassigned,\n  mavlink_handler,\n  ppk_handler,\n  camera_handler,\n  ptp_handler,\n  serial_handler,\n  watchdog,\n  io_service,\n  cbuf,\n  ulg\n};\n")])])]),a("p",[a("code",[t._v("타임스탬프")]),t._v(": 마이크로초 "),a("code",[t._v("log_level")]),t._v(": Linux 커널과 동일")])])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("이름")]),t._v(" "),a("th",[t._v("레벨")]),t._v(" "),a("th",[t._v("설명")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("EMERG")]),t._v(" "),a("td",[t._v("'0'")]),t._v(" "),a("td",[t._v("시스템 사용 불가")])]),t._v(" "),a("tr",[a("td",[t._v("ALERT")]),t._v(" "),a("td",[t._v("'1'")]),t._v(" "),a("td",[t._v("즉시 조치")])]),t._v(" "),a("tr",[a("td",[t._v("CRIT")]),t._v(" "),a("td",[t._v("'2'")]),t._v(" "),a("td",[t._v("임계 조건")])]),t._v(" "),a("tr",[a("td",[t._v("ERR")]),t._v(" "),a("td",[t._v("'3'")]),t._v(" "),a("td",[t._v("오류 조건")])]),t._v(" "),a("tr",[a("td",[t._v("WARNING")]),t._v(" "),a("td",[t._v("'4'")]),t._v(" "),a("td",[t._v("경고 조건")])]),t._v(" "),a("tr",[a("td",[t._v("NOTICE")]),t._v(" "),a("td",[t._v("'5'")]),t._v(" "),a("td",[t._v("정상적이지만 중요한 상태")])]),t._v(" "),a("tr",[a("td",[t._v("INFO")]),t._v(" "),a("td",[t._v("'6'")]),t._v(" "),a("td",[t._v("정보 제공")])]),t._v(" "),a("tr",[a("td",[t._v("DEBUG")]),t._v(" "),a("td",[t._v("'7'")]),t._v(" "),a("td",[t._v("디버그 수준 메시지")])])])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("'S': 독자가 다음 동기화 메시지를 검색하여 손상된 메시지에서 복구할 수 있도록 동기화하는 메시지입니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("struct message_sync_s {\n  struct message_header_s header;\n  uint8_t sync_magic[8];\n};\n")])])]),a("p",[a("code",[t._v("sync_magic")]),t._v(": [0x2F, 0x73, 0x13, 0x20, 0x25, 0x0C, 0xBB, 0x12]")])]),t._v(" "),a("li",[a("p",[t._v("'O': 주어진 기간(ms 단위)의 드롭아웃(로깅 메시지 손실)을 표시합니다. 장치가 충분히 빠르지 않은 경우에는 손실이 발생할 수 있습니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("struct message_dropout_s {\n  struct message_header_s header;\n  uint16_t duration;\n};\n")])])])]),t._v(" "),a("li",[a("p",[t._v("'I': 정보 메세지. 위 참조.")])]),t._v(" "),a("li",[a("p",[t._v("'M': 다중 정보 메세지 위 참조.")])]),t._v(" "),a("li",[a("p",[t._v("'P': 매개변수 메세지 위 참조.")])]),t._v(" "),a("li",[a("p",[t._v("'Q': 매개변수 메시지 위 참조.")])])]),t._v(" "),a("h2",{attrs:{id:"파서-요구-사항"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#파서-요구-사항"}},[t._v("#")]),t._v(" 파서 요구 사항")]),t._v(" "),a("p",[t._v("유효한 ULog 파서는 요구 사항은 다음과 같습니다.")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("알 수 없는 메시지를 무시하여야 합니다(하지만 경고를 인쇄할 수 있음).")])]),t._v(" "),a("li",[a("p",[t._v("미래의/알 수 없는 파일 형식 버전도 구문 분석합니다(하지만 경고를 인쇄할 수 있음).")])]),t._v(" "),a("li",[a("p",[t._v("알 수 없는 비호환성 비트 세트("),a("code",[t._v("ulog_message_flag_bits_s")]),t._v(" 메시지의 "),a("code",[t._v("incompat_flags")]),t._v(")가 포함된 로그의 구문 분석을 거부해야 합니다. 이는 로그에 파서가 처리할 수 없는 주요 변경 사항이 포함되어 있음을 의미합니다.")])]),t._v(" "),a("li",[a("p",[t._v("파서는 메시지 중간에 갑자기 끝나는 로그를 올바르게 처리할 수 있어야 합니다. 완료되지 않은 메시지는 무시하여야 합니다.")])]),t._v(" "),a("li",[a("p",[t._v("추가된 데이터의 경우: 파서는 데이터 섹션이 존재한다고 가정할 수 있습니다. 즉 오프셋은 정의 섹션 뒤의 위치를 가리킵니다.")]),t._v(" "),a("p",[t._v("추가된 데이터는 일반 데이터 섹션의 일부인 것처럼 처리하여야 합니다.")])])]),t._v(" "),a("h2",{attrs:{id:"알려진-구현"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#알려진-구현"}},[t._v("#")]),t._v(" 알려진 구현")]),t._v(" "),a("ul",[a("li",[t._v("PX4-오토파일럿: C++\n"),a("ul",[a("li",[a("a",{attrs:{href:"https://github.com/PX4/PX4-Autopilot/tree/master/src/modules/logger",target:"_blank",rel:"noopener noreferrer"}},[t._v("로거 모듈"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/PX4/PX4-Autopilot/tree/master/src/modules/replay",target:"_blank",rel:"noopener noreferrer"}},[t._v("재생 모듈"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/PX4/PX4-Autopilot/tree/master/src/systemcmds/hardfault_log",target:"_blank",rel:"noopener noreferrer"}},[t._v("hardfault_log 모듈"),a("OutboundLink")],1),t._v(": hardfault 충돌 데이터를 추가합니다.")])])]),t._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/PX4/pyulog",target:"_blank",rel:"noopener noreferrer"}},[t._v("pyulog"),a("OutboundLink")],1),t._v(": python, CLI 스크립트가 있는 ULog 파서 라이브러리")]),t._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/PX4/FlightPlot",target:"_blank",rel:"noopener noreferrer"}},[t._v("FlightPlot"),a("OutboundLink")],1),t._v(": 자바, 로그 플로터")]),t._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/Marxlp/pyFlightAnalysis",target:"_blank",rel:"noopener noreferrer"}},[t._v("pyFlightAnalysis"),a("OutboundLink")],1),t._v(": Python, pyulog 기반의 로그 플로터 및 3D 시각화 도구입니다.")]),t._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/mavlink/mavlink",target:"_blank",rel:"noopener noreferrer"}},[t._v("MAVLink"),a("OutboundLink")],1),t._v(": MAVLink를 통한 ULog 스트리밍용 메시지(적어도 잘린 메시지의 경우 데이터 추가는 지원되지 않습니다.)")]),t._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/mavlink/qgroundcontrol",target:"_blank",rel:"noopener noreferrer"}},[t._v("QGroundControl"),a("OutboundLink")],1),t._v(": C++, MAVLink를 통한 ULog 스트리밍 및 GeoTagging에 대한 최소한의 구문 분석")]),t._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/01org/mavlink-router",target:"_blank",rel:"noopener noreferrer"}},[t._v("mavlink-router"),a("OutboundLink")],1),t._v(": C++, MAVLink를 통한 ULog 스트리밍")]),t._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/ecmnet/MAVGCL",target:"_blank",rel:"noopener noreferrer"}},[t._v("MAVGAnalysis"),a("OutboundLink")],1),t._v(": Java, MAVLink를 통한 ULog 스트리밍 및 플로팅 및 분석용 파서")]),t._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/facontidavide/PlotJuggler",target:"_blank",rel:"noopener noreferrer"}},[t._v("PlotJuggler"),a("OutboundLink")],1),t._v(": 로그 및 시계열을 플롯하는 C++/Qt 응용 프로그램입니다. 버전 2.1.3부터 ULog를 지원합니다.")]),t._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/maxsun/ulogreader",target:"_blank",rel:"noopener noreferrer"}},[t._v("ulogreader"),a("OutboundLink")],1),t._v(": Javascript, ULog 리더 및 파서는 JSON 개체 형식의 로그를 출력합니다.")])]),t._v(" "),a("h2",{attrs:{id:"파일-형식-버전-이력"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#파일-형식-버전-이력"}},[t._v("#")]),t._v(" 파일 형식 버전 이력")]),t._v(" "),a("h3",{attrs:{id:"버전-2의-변경-사항"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#버전-2의-변경-사항"}},[t._v("#")]),t._v(" 버전 2의 변경 사항")]),t._v(" "),a("p",[a("code",[t._v("ulog_message_info_multiple_header_s")]),t._v(" 및 "),a("code",[t._v("ulog_message_flag_bits_s")]),t._v(" 메시지 추가 및 로그에 데이터 추가 기능. 기존 로그에 충돌 데이터를 추가하는 데 사용됩니다. 메시지 중간에 잘린 로그에 데이터가 추가되면, 버전 1 파서로 파싱할 수 없습니다. 그 외의 파서가 알 수 없는 메시지를 무시하면, 순방향 및 역방향 호환성이 제공됩니다.")])])}),[],!1,null,null,null);_.default=s.exports}}]);